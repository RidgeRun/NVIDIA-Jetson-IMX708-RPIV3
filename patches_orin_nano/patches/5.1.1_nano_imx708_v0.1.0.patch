From a6ce608cce8613f78da7478108436a34877d085f Mon Sep 17 00:00:00 2001
From: alfredpchacon <mac.pinnock@ridgerun.com>
Date: Tue, 25 Jul 2023 20:56:08 -0600
Subject: [PATCH] Squashed commit of the following:
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

commit a6505a8f8eabdddecd81201a38dd4bf1dd18ae93
Merge: cee0d5b7e 8386da7eb
Author: Mac Alfred Pinnock Chacón <mac.pinnock@ridgerun.com>
Date:   Tue Jul 25 22:00:38 2023 +0000

    Merge branch 'hotfix/5.1.1/nano/imx708-changes-for-release' into '5.1.1/nano/imx708'

    Hotfix/5.1.1/nano/imx708 changes for release

    See merge request ridgerun/drivers/jetson/orin-drivers!8

commit 8386da7eb042d518ee25760840374ad4d711d0c3
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Tue Jul 25 14:27:47 2023 -0600

    Changes from Nano implementation

commit 4b1b54b7ae5632430594f341462a9c0b796bb67d
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Wed Jul 19 20:45:08 2023 -0600

    Remove trashy code

commit cee0d5b7e5c7e798523485ea25bda908b6b8d1d2
Merge: 3a8e86b05 4bec2ab3c
Author: Mac Alfred Pinnock Chacón <mac.pinnock@ridgerun.com>
Date:   Mon Jul 17 23:42:06 2023 +0000

    Merge branch 'hotfix/5.1.1/nano/imx708-duplicated-copyright' into '5.1.1/nano/imx708'

    Fix duplicated copyright

    See merge request ridgerun/drivers/jetson/orin-drivers!7

commit 4bec2ab3cf834f0cdce2806286953ed153f09289
Author: Mac Alfred Pinnock Chacón <mac.pinnock@ridgerun.com>
Date:   Mon Jul 17 23:39:08 2023 +0000

    Fix duplicated copyright

commit 3a8e86b05b3f14b085cbbafe719d6e2e79544852
Merge: f5e14f6bd fb8039235
Author: Mac Alfred Pinnock Chacón <mac.pinnock@ridgerun.com>
Date:   Sat Jul 1 19:11:10 2023 +0000

    Merge branch '5.1.1/nano/imx708-dev' into '5.1.1/nano/imx708'

    5.1.1/nano/imx708 dev

    See merge request ridgerun/drivers/jetson/orin-drivers!5

commit fb8039235a1ec03af1e10479ca714452a8a69b21
Author: Mac Alfred Pinnock Chacón <mac.pinnock@ridgerun.com>
Date:   Sat Jul 1 19:10:44 2023 +0000

    Fix imx708.h typo

commit 56ce8b4fcdeda0f14e2fada142e87a8fc62fbf66
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Fri Jun 30 09:09:41 2023 -0600

    Remove extra code and initialize variable

commit d1104464a08a74d62d929a60d3af7bd3de1deae6
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Thu Jun 29 21:46:23 2023 -0600

    Remove extra files and initialize variables

commit 4085c92d23ecdeb51db3637c1b483b3cde4f880a
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Fri Jun 23 08:25:33 2023 -0600

    Remove 4 lane config

commit 0094f8bdc7e7b977b357eb879d7c84a358a4f5b8
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Fri Jun 23 08:23:20 2023 -0600

    Remove extra file

commit 5c06593b273ccfb2bdcc39f5a98170e562b49543
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Fri Jun 23 08:22:48 2023 -0600

    Remove extra empty line

commit 8f71d88cba1f0ddce3e5f38bac9b385eb8be98df
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Fri Jun 23 08:22:05 2023 -0600

    Change debug messages category

commit ff6ac37faaaa7c721390f2fb4643d2778737caf5
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Fri Jun 23 08:21:13 2023 -0600

    Add RPI copyright

commit 0d99199def849ab1d02710fe6add4b566eb41d88
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Thu Jun 22 18:48:34 2023 -0600

    Fix missing points in comments

commit 9b44918944cff84af0ac554cc324684784a71664
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Thu Jun 22 17:46:25 2023 -0600

    Add copyright

commit 38cbb444412608b656cc1ef14145299b7a1b8b82
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Thu Jun 22 17:36:46 2023 -0600

    Remove debug code and comments

commit c897c0ea30114260b03197bd5326b4e3d70f2616
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Tue Jun 20 14:51:43 2023 -0600

    Fix half black image issue

commit 4c175f0f6756b782b518ec4f16de780b9dd24b52
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Thu Jun 15 17:22:02 2023 -0600

    Fix timeout error

commit d47fb01a32b6971a0e73ed960a678dfc765c2a44
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Wed Jun 14 10:05:53 2023 -0600

    Change bit depth

commit be53d62a317d92089aa2b99c940fa900f940fbb9
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Tue Jun 13 21:04:31 2023 -0600

    Add more functions for reg dump

commit fcdd523b3dd8feb881f9e2d020b488f22c43c553
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Tue Jun 13 11:16:40 2023 -0600

    Add cache bypass to regdump

commit aa42f1ca04511e4331f66bb4b74a1a65afd58bdc
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Tue Jun 13 10:01:04 2023 -0600

    Add register dump compatibility

commit 3568037beabb966255c718889cc3947d8c8791d7
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Fri Jun 9 14:49:59 2023 -0600

    Change values to default 14 fps

commit 1f8acb248b832691e442c320ea593f58eebbe501
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Wed Jun 7 23:50:56 2023 -0600

    Change clock to discontinuous

commit 35c8bb97e1fc59f9a48602e0604dd9aa36d9b44d
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Wed Jun 7 11:26:34 2023 -0600

    Set framerate to 10 fps

commit ec1061c534de4d4f9569c7b2e67165f5a56aac96
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Tue Jun 6 11:32:26 2023 -0600

    Change config for 24 fps from RPI

commit 377844b100ece9f6157943beec409ff3e691c8b4
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Mon Jun 5 15:24:32 2023 -0600

    Change fps and add port

commit b6aca7c3272bf241df16e2b0745a9bc9202c7da8
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Mon Jun 5 14:12:54 2023 -0600

    Add port index in p3768-0000-a0.dtsi

commit ab741d1fb1a414cdce69de1a887d92865039aedf
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sat Jun 3 18:04:46 2023 -0600

    Fix dependencies name mismatch

commit d4af37452a9958404a668e1410a0612e9f5f4b84
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sat Jun 3 18:03:55 2023 -0600

    Add mode table

commit 4f598a5d2453f5e79efa33e0bbcf7abc75eb118c
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sat Jun 3 18:03:12 2023 -0600

    Fix files names

commit 4b95d50345f197ec9ee5ba125979e842fdf90d40
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sat Jun 3 16:26:21 2023 -0600

    Add c file and header file

commit 97f3dda46156e216d1ad08f15c2b95f13def0ce3
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sat Jun 3 16:23:30 2023 -0600

    Add dtsi in de main dtsi file

commit 0c3db025fc6e9f9042d5afe19e3ce421eaa5eba1
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sat Jun 3 16:21:56 2023 -0600

    Add camera in defconfig

commit ae28ad6004c40252a4ce79ca942dc97a1aee0b42
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sat Jun 3 16:19:26 2023 -0600

    Add Kconfig description

commit e1fa357912503cafa600f430740af3af69300dc8
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sat Jun 3 16:17:44 2023 -0600

    Add .c file and change makefile

commit f0bfe8df660bb05e1521157e7ae340ca477dde9d
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sat Jun 3 16:14:22 2023 -0600

    Add dtb kernel config

commit f12f71686e8ac76cf3700d91ece04c61ad3e5e10
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sat Jun 3 15:17:15 2023 -0600

    Add port description

commit 26bc5c795bbe046f5989983de02e7b018dff64fd
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sat Jun 3 15:16:16 2023 -0600

    Add dtb files for cvb directory using imx219 fix

commit 0b2f6711cf61472883d964139b50ac57bcd1df3f
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sat Jun 3 14:52:28 2023 -0600

    Add common device tree port description files

commit f5e14f6bd834b326ac9a7b42ca143866dc62e18f
Author: Mac Alfred Pinnock Chacón <mac.pinnock@ridgerun.com>
Date:   Fri Jun 2 02:17:29 2023 +0000

    Revert "Fix IMX219 dtb error in missing okay status and port index"

    This reverts commit 9fe9c0f556c57b6f2feab6f41d31f72b484c042b

commit 9fe9c0f556c57b6f2feab6f41d31f72b484c042b
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Thu Jun 1 20:07:24 2023 -0600

    Fix IMX219 dtb error in missing okay status and port index
---
 .../cvb/tegra234-camera-rpicam3-imx708.dtsi   | 277 +++++++
 .../kernel-dts/cvb/tegra234-p3509-a02.dtsi    |   1 +
 .../cvb/tegra234-p3768-0000-a0.dtsi           |  15 +
 .../tegra234-p3768-camera-rpicam3-imx708.dtsi |  61 ++
 .../kernel-5.10/arch/arm64/configs/defconfig  |   1 +
 kernel/nvidia/drivers/media/i2c/Kconfig       |   9 +
 kernel/nvidia/drivers/media/i2c/Makefile      |   1 +
 .../drivers/media/i2c/imx708_mode_tbls.h      | 222 +++++
 kernel/nvidia/drivers/media/i2c/nv_imx708.c   | 774 ++++++++++++++++++
 kernel/nvidia/include/media/imx708.h          |  53 ++
 10 files changed, 1414 insertions(+)
 create mode 100644 hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-camera-rpicam3-imx708.dtsi
 create mode 100644 hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-camera-rpicam3-imx708.dtsi
 create mode 100644 kernel/nvidia/drivers/media/i2c/imx708_mode_tbls.h
 create mode 100644 kernel/nvidia/drivers/media/i2c/nv_imx708.c
 create mode 100644 kernel/nvidia/include/media/imx708.h

diff --git a/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-camera-rpicam3-imx708.dtsi b/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-camera-rpicam3-imx708.dtsi
new file mode 100644
index 000000000..6b864e9f7
--- /dev/null
+++ b/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-camera-rpicam3-imx708.dtsi
@@ -0,0 +1,277 @@
+/*
+ * Copyright (c) 2022-2023, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2023, RidgeRun <support@ridgerun.com>. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/ {
+	tegra-capture-vi  {
+		num-channels = <2>;
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			vi_port0: port@0 {
+				reg = <0>;
+				rpicam3_imx708_vi_in0: endpoint {
+					status="okay";
+					port-index = <0>;
+					bus-width = <2>;
+					remote-endpoint = <&rpicam3_imx708_csi_out0>;
+				};
+			};
+			vi_port1: port@1 {
+				reg = <1>;
+				rpicam3_imx708_vi_in1: endpoint {
+					status="okay";
+					port-index = <2>;
+					bus-width = <2>;
+					remote-endpoint = <&rpicam3_imx708_csi_out1>;
+				};
+			};
+		};
+	};
+
+	host1x@13e00000 {
+		nvcsi@15a00000 {
+			num-channels = <2>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			csi_chan0: channel@0 {
+				reg = <0>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					csi_chan0_port0: port@0 {
+						reg = <0>;
+						rpicam3_imx708_csi_in0: endpoint@0 {
+							status = "okay";
+							port-index = <1>;
+							bus-width = <2>;
+							remote-endpoint = <&rpicam3_imx708_out0>;
+						};
+					};
+					csi_chan0_port1: port@1 {
+						reg = <1>;
+						rpicam3_imx708_csi_out0: endpoint@1 {
+							status = "okay";
+							remote-endpoint = <&rpicam3_imx708_vi_in0>;
+						};
+					};
+				};
+			};
+			csi_chan1: channel@1 {
+				reg = <1>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					csi_chan1_port0: port@0 {
+						reg = <0>;
+						rpicam3_imx708_csi_in1: endpoint@2 {
+							status = "okay";
+							port-index = <2>;
+							bus-width = <2>;
+							remote-endpoint = <&rpicam3_imx708_out1>;
+						};
+					};
+					csi_chan1_port1: port@1 {
+						reg = <1>;
+						rpicam3_imx708_csi_out1: endpoint@3 {
+							status = "okay";
+							remote-endpoint = <&rpicam3_imx708_vi_in1>;
+						};
+					};
+				};
+			};
+		};
+	};
+
+	cam_i2cmux {
+		i2c_0:i2c@0 {
+			imx708_cam0: rpicam3_imx708_a@1a {
+				status = "okay";
+				compatible = "sony,imx708";
+				reg = <0x1a>;
+				devnode = "video0";
+				physical_w = "3.680";
+				physical_h = "2.760";
+				sensor_model = "imx708";
+				use_sensor_mode_id = "true";
+
+				/* IMX708_MODE_4608x2592_14fps */
+				mode0 {
+					mclk_khz = "24000";
+					num_lanes = "2";
+					tegra_sinterface = "serial_a";
+					phy_mode = "DPHY";
+					discontinuous_clk = "yes";
+					dpcm_enable = "false";
+					cil_settletime = "0";
+					lane_polarity = "6";
+
+					active_w = "4608";
+					active_h = "2592";
+					mode_type = "bayer";
+					pixel_phase = "rggb";
+					csi_pixel_bit_depth = "10";
+					readout_orientation = "90";
+					line_length = "4808";
+					inherent_gain = "1";
+					pix_clk_hz = "297600000"; 
+
+					gain_factor = "16";
+					framerate_factor = "1000000";
+					exposure_factor = "1000000";
+					min_gain_val = "16"; 
+					max_gain_val = "256"; 
+					step_gain_val = "1";
+					default_gain = "16";
+					min_hdr_ratio = "1";
+					max_hdr_ratio = "1";
+					min_framerate = "2000000";
+					max_framerate = "14000000";
+					step_framerate = "1";
+					default_framerate = "14000000";
+					min_exp_time = "500";
+					max_exp_time = "65487";
+					step_exp_time = "1";
+					default_exp_time = "1600";
+					embedded_metadata_height = "4";
+				};
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					port@0 {
+						reg = <0>;
+						rpicam3_imx708_out0: endpoint {
+							port-index = <0>;
+							bus-width = <2>;
+							remote-endpoint = <&rpicam3_imx708_csi_in0>;
+						};
+					};
+				};
+			};
+		};
+		i2c_1: i2c@1 {
+			imx708_cam1: rpicam3_imx708_c@1a {
+				status = "okay";
+				compatible = "ridgerun,imx708";
+				reg = <0x1a>;
+				devnode = "video1";
+				physical_w = "3.680";
+				physical_h = "2.760";
+				sensor_model = "imx708";
+				use_sensor_mode_id = "true";
+
+				/* IMX708_MODE_4608x2592_14fps */
+				mode0 {
+					mclk_khz = "24000";
+					num_lanes = "2";
+					tegra_sinterface = "serial_c";
+					phy_mode = "DPHY";
+					discontinuous_clk = "yes";
+					dpcm_enable = "false";
+					cil_settletime = "0";
+					lane_polarity = "0";
+
+					active_w = "4608";
+					active_h = "2592";
+					mode_type = "bayer";
+					pixel_phase = "rggb";
+					csi_pixel_bit_depth = "10";
+					readout_orientation = "90";
+					line_length = "4808";
+					inherent_gain = "1";
+					pix_clk_hz = "297600000";
+
+					gain_factor = "16";
+					framerate_factor = "1000000";
+					exposure_factor = "1000000";
+					min_gain_val = "16"; 
+					max_gain_val = "256"; 
+					step_gain_val = "1";
+					default_gain = "16";
+					min_hdr_ratio = "1";
+					max_hdr_ratio = "1";
+					min_framerate = "2000000";
+					max_framerate = "14000000";
+					step_framerate = "1";
+					default_framerate = "14000000";
+					min_exp_time = "500";
+					max_exp_time = "65487";
+					step_exp_time = "1";
+					default_exp_time = "1600";
+					embedded_metadata_height = "4";
+				};
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					port@0 {
+						reg = <0>;
+						rpicam3_imx708_out1: endpoint {
+							status = "okay";
+							port-index = <2>;
+							bus-width = <2>;
+							remote-endpoint = <&rpicam3_imx708_csi_in1>;
+						};
+					};
+				};
+			};
+		};
+	};
+};
+
+/ {
+	tegra-camera-platform {
+		compatible = "nvidia, tegra-camera-platform";
+		num_csi_lanes = <4>;
+		max_lane_speed = <2500000>;
+		min_bits_per_pixel = <10>;
+		vi_peak_byte_per_pixel = <2>;
+		vi_bw_margin_pct = <25>;
+		max_pixel_rate = <7500000>;
+		isp_peak_byte_per_pixel = <5>;
+		isp_bw_margin_pct = <25>;
+
+		modules {
+			cam_module0: module0 {
+				status = "okay";
+				badge = "jakku_front_RBPCV3";
+				position = "front";
+				orientation = "1";
+				cam_module0_drivernode0: drivernode0 {
+					status = "okay";
+					pcl_id = "v4l2_sensor";
+					devname = "imx708 9-001a";
+					proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@0/rpicam3_imx708_a@1a";
+				};
+			};
+			cam_module1: module1 {
+				badge = "jakku_rear_RBPCV3";
+				position = "rear";
+				orientation = "1";
+				cam_module1_drivernode0: drivernode0 {
+					status = "okay";
+					pcl_id = "v4l2_sensor";
+					devname = "imx708 10-001a";
+					proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@1/rpicam3_imx708_c@1a";
+				};
+			};
+		};
+	};
+};
diff --git a/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3509-a02.dtsi b/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3509-a02.dtsi
index b6f1047d2..daf32c0c9 100644
--- a/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3509-a02.dtsi
+++ b/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3509-a02.dtsi
@@ -16,6 +16,7 @@
 #include "tegra234-p3509-a02-pcie.dtsi"
 #include "tegra234-p3509-a02-fixed-regulator.dtsi"
 #include "tegra234-p3509-audio.dtsi"
+#include "tegra234-p3768-camera-rpicam3-imx708.dtsi"
 #include "tegra234-p3768-camera-rbpcv3-imx477.dtsi"
 #include "tegra234-p3768-camera-rbpcv2-imx219.dtsi"
 
diff --git a/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-0000-a0.dtsi b/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-0000-a0.dtsi
index 01f41c8d0..a3644b868 100644
--- a/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-0000-a0.dtsi
+++ b/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-0000-a0.dtsi
@@ -18,6 +18,7 @@
 #include "tegra234-p3768-audio.dtsi"
 #include "tegra234-p3768-camera-rbpcv3-imx477.dtsi"
 #include "tegra234-p3768-camera-rbpcv2-imx219.dtsi"
+#include "tegra234-p3768-camera-rpicam3-imx708.dtsi"
 
 / {
 	gpio-keys {
@@ -334,6 +335,20 @@
 					};
 				};
 			};
+
+			rbpcv3_imx708_a@1a {
+				mode0 {
+					tegra_sinterface = "serial_b";
+					lane_polarity = "6";
+				};
+				ports {
+					port@0 {
+						endpoint {
+							port-index = <1>;
+						};
+					};
+				};
+			};
 		};
 	};
 };
diff --git a/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-camera-rpicam3-imx708.dtsi b/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-camera-rpicam3-imx708.dtsi
new file mode 100644
index 000000000..cd7e43584
--- /dev/null
+++ b/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-camera-rpicam3-imx708.dtsi
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2022, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2023, RidgeRun.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "tegra234-camera-rpicam3-imx708.dtsi"
+
+#define CAM0_PWDN	TEGRA234_MAIN_GPIO(H, 6)
+#define CAM1_PWDN	TEGRA234_MAIN_GPIO(AC, 0)
+#define CAM_I2C_MUX 	TEGRA234_AON_GPIO(CC, 3)
+
+/ {
+	cam_i2cmux {
+		status = "okay";
+		compatible = "i2c-mux-gpio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		mux-gpios = <&tegra_aon_gpio CAM_I2C_MUX GPIO_ACTIVE_HIGH>;
+		i2c-parent = <&cam_i2c>;
+		i2c@0 {
+			status = "okay";
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			rpicam3_imx708_a@1a {
+				reset-gpios = <&tegra_main_gpio CAM0_PWDN GPIO_ACTIVE_HIGH>;
+			};
+		};
+		i2c@1 {
+			status = "okay";
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			rpicam3_imx708_c@1a {
+				reset-gpios = <&tegra_main_gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
+			};
+		};
+	};
+
+	gpio@2200000 {
+		camera-control-output-low {
+			gpio-hog;
+			output-low;
+			gpios = <CAM0_PWDN 0 CAM1_PWDN 0>;
+			label = "cam0-pwdn","cam1-pwdn";
+		};
+	};
+};
diff --git a/kernel/kernel-5.10/arch/arm64/configs/defconfig b/kernel/kernel-5.10/arch/arm64/configs/defconfig
index bda2dff57..53b23f47a 100644
--- a/kernel/kernel-5.10/arch/arm64/configs/defconfig
+++ b/kernel/kernel-5.10/arch/arm64/configs/defconfig
@@ -886,6 +886,7 @@ CONFIG_VIDEO_ECAM=m
 CONFIG_NV_VIDEO_IMX185=m
 CONFIG_NV_VIDEO_IMX219=m
 CONFIG_NV_VIDEO_IMX477=m
+CONFIG_NV_VIDEO_IMX708=m
 CONFIG_NV_VIDEO_IMX268=m
 CONFIG_NV_VIDEO_IMX274=m
 CONFIG_NV_VIDEO_IMX318=m
diff --git a/kernel/nvidia/drivers/media/i2c/Kconfig b/kernel/nvidia/drivers/media/i2c/Kconfig
index 0592973a8..7d8c07269 100644
--- a/kernel/nvidia/drivers/media/i2c/Kconfig
+++ b/kernel/nvidia/drivers/media/i2c/Kconfig
@@ -13,6 +13,15 @@ config NV_VIDEO_IMX185
 	To compile this driver as a module, choose M here: the module
 	will be called imx185.
 
+config NV_VIDEO_IMX708
+        tristate "IMX708 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	  This driver supports IMX708 camera sensor from Sony
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called IMX708.
+
 config NV_VIDEO_IMX477
         tristate "IMX477 camera sensor support"
 	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
diff --git a/kernel/nvidia/drivers/media/i2c/Makefile b/kernel/nvidia/drivers/media/i2c/Makefile
index f8f6c3ba0..b9c2a7950 100644
--- a/kernel/nvidia/drivers/media/i2c/Makefile
+++ b/kernel/nvidia/drivers/media/i2c/Makefile
@@ -5,6 +5,7 @@ ccflags-y += -I$(srctree)/drivers/video/tegra/camera
 
 obj-$(CONFIG_NV_VIDEO_IMX185) += nv_imx185.o
 obj-$(CONFIG_NV_VIDEO_IMX185) += nv_imx185_v1.o
+obj-$(CONFIG_NV_VIDEO_IMX708) += nv_imx708.o
 obj-$(CONFIG_NV_VIDEO_IMX477) += nv_imx477.o
 obj-$(CONFIG_NV_VIDEO_IMX219) += nv_imx219.o
 obj-$(CONFIG_NV_VIDEO_IMX268) += nv_imx268.o
diff --git a/kernel/nvidia/drivers/media/i2c/imx708_mode_tbls.h b/kernel/nvidia/drivers/media/i2c/imx708_mode_tbls.h
new file mode 100644
index 000000000..0d273d1a8
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/imx708_mode_tbls.h
@@ -0,0 +1,222 @@
+/*
+ * Copyright (c) 2020-2023, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (C) 2022, Raspberry Pi Ltd
+ * Copyright (c) 2023, RidgeRun <support@ridgerun.com>. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __IMX708_I2C_TABLES__
+#define __IMX708_I2C_TABLES__
+
+#include <media/camera_common.h>
+
+#define IMX708_TABLE_WAIT_MS 0
+#define IMX708_TABLE_END 1
+#define IMX708_WAIT_MS 1
+#define IMX708_STANDBY_REG 0x0100
+
+#define imx708_reg struct reg_8
+
+static const imx708_reg imx708_start[] = {
+	{IMX708_STANDBY_REG, 0x1},
+	{IMX708_TABLE_WAIT_MS, IMX708_WAIT_MS*3},
+	{IMX708_TABLE_END, 0x00}
+};
+
+static const imx708_reg imx708_stop[] = {
+	{IMX708_STANDBY_REG, 0x0},
+	{IMX708_TABLE_END, 0x00}
+};
+
+static const imx708_reg imx708_mode_common[] = {
+	/* software reset */
+	{0x0103, 0x01},
+	{IMX708_TABLE_WAIT_MS, IMX708_WAIT_MS*10},
+	{0x0100, 0x00},
+	{0x0136, 0x18},
+	{0x0137, 0x00},
+	{0x33F0, 0x02},
+	{0x33F1, 0x05},
+	{0x3062, 0x00},
+	{0x3063, 0x12},
+	{0x3068, 0x00},
+	{0x3069, 0x12},
+	{0x306A, 0x00},
+	{0x306B, 0x30},
+	{0x3076, 0x00},
+	{0x3077, 0x30},
+	{0x3078, 0x00},
+	{0x3079, 0x30},
+	{0x5E54, 0x0C},
+	{0x6E44, 0x00},
+	{0xB0B6, 0x01},
+	{0xE829, 0x00},
+	{0xF001, 0x08},
+	{0xF003, 0x08},
+	{0xF00D, 0x10},
+	{0xF00F, 0x10},
+	{0xF031, 0x08},
+	{0x0830, 0x01},
+	{0x0831, 0x01}, 
+	{0x0832, 0x01},
+	{0xF033, 0x08},
+	{0xF03D, 0x10},
+	{0xF03F, 0x10},
+	{0x0112, 0x0a},
+	{0x0113, 0x0a},
+	{0x0114, 0x01},
+	{0x0B8E, 0x01},
+	{0x0B8F, 0x00},
+	{0x0B94, 0x01},
+	{0x0B95, 0x00},
+	{0x3400, 0x01},
+	{0x3478, 0x01},
+	{0x3479, 0x1c},
+	{0x3091, 0x01},
+	{0x3092, 0x00},
+	{0x3419, 0x00},
+	{0xBCF1, 0x02},
+	{0x3094, 0x01},
+	{0x3095, 0x01},
+	{0x3362, 0x00},
+	{0x3363, 0x00},
+	{0x3364, 0x00},
+	{0x3365, 0x00},
+	{0x0138, 0x01},
+	{IMX708_TABLE_END, 0x0000}
+};
+
+static const imx708_reg imx708_mode_4608x2592_14fps[] = {
+	{0x0342, 0x3D},
+	{0x0343, 0x20},
+	{0x0340, 0x0A},
+	{0x0341, 0x5a},
+	{0x0344, 0x00},
+	{0x0345, 0x00},
+	{0x0346, 0x00},
+	{0x0347, 0x00},
+	{0x0348, 0x11},
+	{0x0349, 0xFF},
+	{0x034A, 0X0A},
+	{0x034B, 0x1F},
+	{0x0220, 0x62},
+	{0x0222, 0x01},
+	{0x0900, 0x00},
+	{0x0901, 0x11},
+	{0x0902, 0x0A},
+	{0x3200, 0x01},
+	{0x3201, 0x01},
+	{0x32D5, 0x01},
+	{0x32D6, 0x00},
+	{0x32DB, 0x01},
+	{0x32DF, 0x00},
+	{0x350C, 0x00},
+	{0x350D, 0x00},
+	{0x0408, 0x00},
+	{0x0409, 0x00},
+	{0x040A, 0x00},
+	{0x040B, 0x00},
+	{0x040C, 0x12},
+	{0x040D, 0x00},
+	{0x040E, 0x0A},
+	{0x040F, 0x20},
+	{0x034C, 0x12},
+	{0x034D, 0x00},
+	{0x034E, 0x0A},
+	{0x034F, 0x20},
+	{0x0301, 0x05},
+	{0x0303, 0x02},
+	{0x0305, 0x02},
+	{0x0306, 0x00},
+	{0x0307, 0x7C},
+	{0x030B, 0x02},
+	{0x030D, 0x04},
+	{0x030E, 0x01},
+	{0x030F, 0x2C},
+	{0x0310, 0x01},
+	{0x3CA0, 0x00},
+	{0x3CA1, 0x64},
+	{0x3CA4, 0x00},
+	{0x3CA5, 0x00},
+	{0x3CA6, 0x00},
+	{0x3CA7, 0x00},
+	{0x3CAA, 0x00},
+	{0x3CAB, 0x00},
+	{0x3CB8, 0x00},
+	{0x3CB9, 0x08},
+	{0x3CBA, 0x00},
+	{0x3CBB, 0x00},
+	{0x3CBC, 0x00},
+	{0x3CBD, 0x3C},
+	{0x3CBE, 0x00},
+	{0x3CBF, 0x00},
+	{0x0202, 0x0A},
+	{0x0203, 0x2a},
+	{0x0224, 0x01},
+	{0x0225, 0xF4},
+	{0x3116, 0x01},
+	{0x3117, 0xF4},
+	{0x0204, 0x03},
+	{0x0205, 0x55},
+	{0x0216, 0x00},
+	{0x0217, 0x00},
+	{0x0218, 0x01},
+	{0x0219, 0x00},
+	{0x020E, 0x01},
+	{0x020F, 0x00},
+	{0x3118, 0x00},
+	{0x3119, 0x00},
+	{0x311A, 0x01},
+	{0x311B, 0x00},
+	{0x341a, 0x00},
+	{0x341b, 0x00},
+	{0x341c, 0x00},
+	{0x341d, 0x00},
+	{0x341e, 0x01},
+	{0x341f, 0x20},
+	{0x3420, 0x00},
+	{0x3421, 0xd8},
+	{0xC428, 0x00},
+	{0xC429, 0x04},
+	{0x3366, 0x00},
+	{0x3367, 0x00},
+	{0x3368, 0x00},
+	{0x3369, 0x00},
+	{IMX708_TABLE_WAIT_MS, IMX708_WAIT_MS},
+	{IMX708_TABLE_END, 0x0000}
+};
+
+enum {
+	IMX708_MODE_4608x2592_14FPS,
+	IMX708_MODE_COMMON,
+	IMX708_START_STREAM,
+	IMX708_STOP_STREAM,
+};
+
+static const imx708_reg *mode_table[] = {
+	[IMX708_MODE_4608x2592_14FPS] = imx708_mode_4608x2592_14fps,
+	[IMX708_MODE_COMMON] = imx708_mode_common,
+	[IMX708_START_STREAM] = imx708_start,
+	[IMX708_STOP_STREAM] = imx708_stop,
+};
+
+static const int imx708_14_fr[] = {
+	14,
+};
+
+static const struct camera_common_frmfmt imx708_frmfmt[] = {
+	{{4608, 2592}, imx708_14_fr, 1, 0, IMX708_MODE_4608x2592_14FPS},
+};
+#endif
diff --git a/kernel/nvidia/drivers/media/i2c/nv_imx708.c b/kernel/nvidia/drivers/media/i2c/nv_imx708.c
new file mode 100644
index 000000000..c33fc24b5
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/nv_imx708.c
@@ -0,0 +1,774 @@
+/*
+ * imx708.c - imx708 sensor driver
+ *
+ * Copyright (c) 2021-2023, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2023, RidgeRun <support@ridgerun.com>. All rights reserved.
+ *
+ * Contact us: support@ridgerun.com
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <media/tegra_v4l2_camera.h>
+#include <media/tegracam_core.h>
+#include <media/imx708.h>
+
+#include "../platform/tegra/camera/camera_gpio.h"
+#include "imx708_mode_tbls.h"
+
+static const struct of_device_id imx708_of_match[] = {
+	{.compatible = "sony,imx708",},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, imx708_of_match);
+
+static const u32 ctrl_cid_list[] = {
+	TEGRA_CAMERA_CID_GAIN,
+	TEGRA_CAMERA_CID_EXPOSURE,
+	TEGRA_CAMERA_CID_FRAME_RATE,
+	TEGRA_CAMERA_CID_SENSOR_MODE_ID,
+};
+
+struct imx708 {
+	struct i2c_client *i2c_client;
+	struct v4l2_subdev *subdev;
+	u16 fine_integ_time;
+	u32 frame_length;
+	struct camera_common_data *s_data;
+	struct tegracam_device *tc_dev;
+};
+
+static const struct regmap_config sensor_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+#if KERNEL_VERSION(5, 4, 0) > LINUX_VERSION_CODE
+		.use_single_rw = true,
+#else
+		.use_single_read = true,
+		.use_single_write = true,
+#endif
+};
+
+static inline void imx708_get_frame_length_regs(imx708_reg * regs,
+						u32 frame_length)
+{
+	regs->addr = IMX708_FRAME_LENGTH_ADDR_MSB;
+	regs->val = (frame_length >> 8) & 0xff;
+	(regs + 1)->addr = IMX708_FRAME_LENGTH_ADDR_LSB;
+	(regs + 1)->val = (frame_length) & 0xff;
+}
+
+static inline void imx708_get_coarse_integ_time_regs(imx708_reg * regs,
+						     u32 coarse_time)
+{
+	regs->addr = IMX708_COARSE_INTEG_TIME_ADDR_MSB;
+	regs->val = (coarse_time >> 8) & 0xff;
+	(regs + 1)->addr = IMX708_COARSE_INTEG_TIME_ADDR_LSB;
+	(regs + 1)->val = (coarse_time) & 0xff;
+}
+
+static inline void imx708_get_gain_reg(imx708_reg * reg, u16 gain)
+{
+	reg->addr = IMX708_ANALOG_GAIN_ADDR_MSB;
+	reg->val = (gain >> IMX708_SHIFT_8_BITS) & IMX708_MASK_LSB_2_BITS;
+
+	(reg + 1)->addr = IMX708_ANALOG_GAIN_ADDR_LSB;
+	(reg + 1)->val = (gain) & IMX708_MASK_LSB_8_BITS;
+}
+
+static inline int imx708_read_reg(struct camera_common_data *s_data,
+				  u16 addr, u8 * val)
+{
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(s_data->regmap, addr, &reg_val);
+	*val = reg_val & 0xff;
+
+	return err;
+}
+
+static inline int imx708_write_reg(struct camera_common_data *s_data,
+				   u16 addr, u8 val)
+{
+	int err = 0;
+
+	err = regmap_write(s_data->regmap, addr, val);
+	if (err)
+		dev_err(s_data->dev, "%s: i2c write failed, 0x%x = %x",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int imx708_write_table(struct imx708 *priv, const imx708_reg table[])
+{
+	return regmap_util_write_table_8(priv->s_data->regmap, table, NULL, 0,
+					 IMX708_TABLE_WAIT_MS,
+					 IMX708_TABLE_END);
+}
+
+static int imx708_set_group_hold(struct tegracam_device *tc_dev, bool val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct device *dev = tc_dev->dev;
+	int err = 0;
+
+	dev_dbg(dev, "%s: Setting group hold control to: %u\n", __func__, val);
+
+	err = imx708_write_reg(s_data, IMX708_GROUP_HOLD_ADDR, val);
+	if (err) {
+		dev_err(dev, "%s: Group hold control error\n", __func__);
+		return err;
+	}
+
+	return 0;
+}
+
+static int imx708_get_fine_integ_time(struct imx708 *priv, u16 * fine_time)
+{
+	struct camera_common_data *s_data = priv->s_data;
+	int err = 0;
+	u8 reg_val[2] = {0};
+
+	err = imx708_read_reg(s_data, IMX708_FINE_INTEG_TIME_ADDR_MSB,
+			      &reg_val[0]);
+	if (err)
+		goto done;
+
+	err = imx708_read_reg(s_data, IMX708_FINE_INTEG_TIME_ADDR_LSB,
+			      &reg_val[1]);
+	if (err)
+		goto done;
+
+	*fine_time = (reg_val[0] << 8) | reg_val[1];
+
+done:
+	return err;
+}
+
+static int imx708_set_gain(struct tegracam_device *tc_dev, s64 val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct device *dev = s_data->dev;
+	const struct sensor_mode_properties *mode =
+	    &s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+	int err = 0; 
+	int i = 0;
+	imx708_reg gain_reg[2] = {0};
+	s16 gain = 0;
+
+	dev_dbg(dev, "%s: Setting gain control to: %lld\n", __func__, val);
+
+	/* Gain Formula:
+	   Gain = (IMX708_GAIN_C0 - (IMX708_GAIN_C0 * gain_factor / val))
+	 */
+	gain =
+	    (s16) (IMX708_ANALOG_GAIN_C0 -
+		   (mode->control_properties.gain_factor *
+		    IMX708_ANALOG_GAIN_C0 / val));
+
+	dev_dbg(dev, "%s: val: %lld (/%d) [times], gain: %u\n",
+		__func__, val, mode->control_properties.gain_factor, gain);
+
+	imx708_get_gain_reg(gain_reg, (u16) gain);
+
+	for (i = 0; i < ARRAY_SIZE(gain_reg); i++) {
+		err = imx708_write_reg(s_data, gain_reg[i].addr,
+				       gain_reg[i].val);
+		if (err) {
+			dev_err(dev, "%s: gain control error\n", __func__);
+			break;
+		}
+	}
+
+	return err;
+}
+
+static int imx708_set_frame_rate(struct tegracam_device *tc_dev, s64 val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct imx708 *priv = (struct imx708 *)tc_dev->priv;
+	struct device *dev = tc_dev->dev;
+	const struct sensor_mode_properties *mode =
+	    &s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+
+	int err = 0;
+	imx708_reg fl_regs[2] = {0};
+	u32 frame_length = 0;
+	int i = 0;
+
+	dev_dbg(dev, "%s: Setting framerate control to: %lld\n", __func__, val);
+
+	frame_length = (u32)(mode->signal_properties.pixel_clock.val *
+		(u64)mode->control_properties.framerate_factor /
+		mode->image_properties.line_length / val);
+
+	dev_dbg(dev,
+		"%s: val: %llde-6 [fps], frame_length: %u [lines]\n",
+		__func__, val, frame_length);
+
+	imx708_get_frame_length_regs(fl_regs, frame_length);
+	for (i = 0; i < 2; i++) {
+		err = imx708_write_reg(s_data, fl_regs[i].addr, fl_regs[i].val);
+		if (err) {
+			dev_err(dev,
+				"%s: frame_length control error\n", __func__);
+			return err;
+		}
+	}
+
+	priv->frame_length = frame_length;
+
+	return err;
+}
+
+static int imx708_set_exposure(struct tegracam_device *tc_dev, s64 val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct imx708 *priv = (struct imx708 *)tc_dev->priv;
+	struct device *dev = tc_dev->dev;
+	const struct sensor_mode_properties *mode =
+	    &s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+
+	int err = 0;
+	imx708_reg ct_regs[2] = {0};
+	const s32 fine_integ_time_factor = priv->fine_integ_time *
+	    mode->control_properties.exposure_factor /
+	    mode->signal_properties.pixel_clock.val;
+	u32 coarse_time = 0;
+	int i = 0;
+
+	dev_dbg(dev, "%s: Setting exposure control to: %lld\n", __func__, val);
+
+	coarse_time = (val - fine_integ_time_factor)
+	    * mode->signal_properties.pixel_clock.val
+	    / mode->control_properties.exposure_factor
+	    / mode->image_properties.line_length;
+
+	dev_dbg(dev, "%s: val: %lld [us], coarse_time: %d [lines]\n",
+		__func__, val, coarse_time);
+
+	imx708_get_coarse_integ_time_regs(ct_regs, coarse_time);
+
+	for (i = 0; i < 2; i++) {
+		err = imx708_write_reg(s_data, ct_regs[i].addr, ct_regs[i].val);
+		if (err) {
+			dev_err(dev,
+				"%s: coarse_time control error\n", __func__);
+			return err;
+		}
+	}
+
+	return err;
+}
+
+static struct tegracam_ctrl_ops imx708_ctrl_ops = {
+	.numctrls = ARRAY_SIZE(ctrl_cid_list),
+	.ctrl_cid_list = ctrl_cid_list,
+	.set_gain = imx708_set_gain,
+	.set_exposure = imx708_set_exposure,
+	.set_frame_rate = imx708_set_frame_rate,
+	.set_group_hold = imx708_set_group_hold,
+};
+
+static int imx708_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+
+	dev_dbg(dev, "%s: power on\n", __func__);
+	if (pdata && pdata->power_on) {
+		err = pdata->power_on(pw);
+		if (err)
+			dev_err(dev, "%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+
+	if (pw->reset_gpio) {
+		if (gpio_cansleep(pw->reset_gpio))
+			gpio_set_value_cansleep(pw->reset_gpio, 0);
+		else
+			gpio_set_value(pw->reset_gpio, 0);
+	}
+
+	if (unlikely(!(pw->avdd || pw->iovdd || pw->dvdd)))
+		goto skip_power_seqn;
+
+	usleep_range(10, 20);
+
+	if (pw->avdd) {
+		err = regulator_enable(pw->avdd);
+		if (err)
+			goto imx708_avdd_fail;
+	}
+
+	if (pw->iovdd) {
+		err = regulator_enable(pw->iovdd);
+		if (err)
+			goto imx708_iovdd_fail;
+	}
+
+	if (pw->dvdd) {
+		err = regulator_enable(pw->dvdd);
+		if (err)
+			goto imx708_dvdd_fail;
+	}
+
+	usleep_range(10, 20);
+
+skip_power_seqn:
+	if (pw->reset_gpio) {
+		if (gpio_cansleep(pw->reset_gpio))
+			gpio_set_value_cansleep(pw->reset_gpio, 1);
+		else
+			gpio_set_value(pw->reset_gpio, 1);
+	}
+
+	/* Need to wait for t4 + t5 + t9 + t10 time as per the data sheet */
+	/* t4 - 200us, t5 - 21.2ms, t9 - 1.2ms t10 - 270 ms */
+	usleep_range(300000, 300100);
+
+	pw->state = SWITCH_ON;
+
+	return 0;
+
+imx708_dvdd_fail:
+	regulator_disable(pw->iovdd);
+
+imx708_iovdd_fail:
+	regulator_disable(pw->avdd);
+
+imx708_avdd_fail:
+	dev_err(dev, "%s failed.\n", __func__);
+
+	return -ENODEV;
+}
+
+static int imx708_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+
+	dev_dbg(dev, "%s: power off\n", __func__);
+
+	if (pdata && pdata->power_off) {
+		err = pdata->power_off(pw);
+		if (err) {
+			dev_err(dev, "%s failed.\n", __func__);
+			return err;
+		}
+	} else {
+		if (pw->reset_gpio) {
+			if (gpio_cansleep(pw->reset_gpio))
+				gpio_set_value_cansleep(pw->reset_gpio, 0);
+			else
+				gpio_set_value(pw->reset_gpio, 0);
+		}
+
+		usleep_range(10, 10);
+
+		if (pw->dvdd)
+			regulator_disable(pw->dvdd);
+		if (pw->iovdd)
+			regulator_disable(pw->iovdd);
+		if (pw->avdd)
+			regulator_disable(pw->avdd);
+	}
+
+	pw->state = SWITCH_OFF;
+
+	return 0;
+}
+
+static int imx708_power_put(struct tegracam_device *tc_dev)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+
+	if (unlikely(!pw))
+		return -EFAULT;
+
+	if (likely(pw->dvdd))
+		devm_regulator_put(pw->dvdd);
+
+	if (likely(pw->avdd))
+		devm_regulator_put(pw->avdd);
+
+	if (likely(pw->iovdd))
+		devm_regulator_put(pw->iovdd);
+
+	pw->dvdd = NULL;
+	pw->avdd = NULL;
+	pw->iovdd = NULL;
+
+	if (likely(pw->reset_gpio))
+		gpio_free(pw->reset_gpio);
+
+	return 0;
+}
+
+static int imx708_power_get(struct tegracam_device *tc_dev)
+{
+	struct device *dev = tc_dev->dev;
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct clk *parent;
+	int err = 0;
+
+	if (!pdata) {
+		dev_err(dev, "pdata missing\n");
+		return -EFAULT;
+	}
+
+	/* Sensor MCLK (aka. INCK) */
+	if (pdata->mclk_name) {
+		pw->mclk = devm_clk_get(dev, pdata->mclk_name);
+		if (IS_ERR(pw->mclk)) {
+			dev_err(dev, "unable to get clock %s\n",
+				pdata->mclk_name);
+			return PTR_ERR(pw->mclk);
+		}
+
+		if (pdata->parentclk_name) {
+			parent = devm_clk_get(dev, pdata->parentclk_name);
+			if (IS_ERR(parent)) {
+				dev_err(dev, "unable to get parent clock %s",
+					pdata->parentclk_name);
+			} else
+				clk_set_parent(pw->mclk, parent);
+		}
+	}
+
+	/* analog 2.8v */
+	if (pdata->regulators.avdd)
+		err |= camera_common_regulator_get(dev,
+						   &pw->avdd,
+						   pdata->regulators.avdd);
+	/* IO 1.8v */
+	if (pdata->regulators.iovdd)
+		err |= camera_common_regulator_get(dev,
+						   &pw->iovdd,
+						   pdata->regulators.iovdd);
+	/* dig 1.2v */
+	if (pdata->regulators.dvdd)
+		err |= camera_common_regulator_get(dev,
+						   &pw->dvdd,
+						   pdata->regulators.dvdd);
+	if (err) {
+		dev_err(dev, "%s: unable to get regulator(s)\n", __func__);
+		goto done;
+	}
+
+	/* Reset or ENABLE GPIO */
+	pw->reset_gpio = pdata->reset_gpio;
+	err = gpio_request(pw->reset_gpio, "cam_reset_gpio");
+	if (err < 0) {
+		dev_err(dev, "%s: unable to request reset_gpio (%d)\n",
+			__func__, err);
+		goto done;
+	}
+
+done:
+	pw->state = SWITCH_OFF;
+
+	return err;
+}
+
+static struct camera_common_pdata *imx708_parse_dt(struct tegracam_device
+						   *tc_dev)
+{
+	struct device *dev = tc_dev->dev;
+	struct device_node *np = dev->of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	struct camera_common_pdata *ret = NULL;
+	int err = 0;
+	int gpio = 0;
+
+	if (!np)
+		return NULL;
+
+	match = of_match_device(imx708_of_match, dev);
+	if (!match) {
+		dev_err(dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	board_priv_pdata = devm_kzalloc(dev,
+					sizeof(*board_priv_pdata), GFP_KERNEL);
+	if (!board_priv_pdata)
+		return NULL;
+
+	gpio = of_get_named_gpio(np, "reset-gpios", 0);
+	if (gpio < 0) {
+		if (gpio == -EPROBE_DEFER)
+			ret = ERR_PTR(-EPROBE_DEFER);
+		dev_err(dev, "reset-gpios not found\n");
+		goto error;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+
+	err = of_property_read_string(np, "avdd-reg",
+				      &board_priv_pdata->regulators.avdd);
+	err |= of_property_read_string(np, "iovdd-reg",
+				       &board_priv_pdata->regulators.iovdd);
+	err |= of_property_read_string(np, "dvdd-reg",
+				       &board_priv_pdata->regulators.dvdd);
+	if (err)
+		dev_dbg(dev, "avdd, iovdd and/or dvdd reglrs. not present, "
+			"assume sensor powered independently\n");
+
+	board_priv_pdata->has_eeprom = of_property_read_bool(np, "has-eeprom");
+
+	return board_priv_pdata;
+
+error:
+	devm_kfree(dev, board_priv_pdata);
+
+	return ret;
+}
+
+static int imx708_set_mode(struct tegracam_device *tc_dev)
+{
+	struct imx708 *priv = (struct imx708 *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = tc_dev->s_data;
+
+	int err = 0;
+
+	err = imx708_write_table(priv, mode_table[IMX708_MODE_COMMON]);
+	if (err)
+	{
+		dev_err(tc_dev->dev, "failed writing common mode err:%d\n", err);
+		return err;
+	}
+
+	if (s_data->mode < 0)
+		return -EINVAL;
+	err = imx708_write_table(priv, mode_table[s_data->mode]);
+	if (err)
+	{
+		dev_err(tc_dev->dev, "failed to write mode %d  err:%d\n", s_data->mode, err);
+		return err;
+	}
+	
+	return 0;
+}
+
+
+static int imx708_start_streaming(struct tegracam_device *tc_dev)
+{
+	struct imx708 *priv = (struct imx708 *)tegracam_get_privdata(tc_dev);
+
+	dev_dbg(tc_dev->dev, "%s:\n", __func__);
+
+	return imx708_write_table(priv, mode_table[IMX708_START_STREAM]);
+}
+
+static int imx708_stop_streaming(struct tegracam_device *tc_dev)
+{
+	int err = 0;
+
+	struct imx708 *priv = (struct imx708 *)tegracam_get_privdata(tc_dev);
+
+	dev_dbg(tc_dev->dev, "%s:\n", __func__);
+
+	err = imx708_write_table(priv, mode_table[IMX708_STOP_STREAM]);
+
+	return err;
+}
+
+static struct camera_common_sensor_ops imx708_common_ops = {
+	.numfrmfmts = ARRAY_SIZE(imx708_frmfmt),
+	.frmfmt_table = imx708_frmfmt,
+	.power_on = imx708_power_on,
+	.power_off = imx708_power_off,
+	.write_reg = imx708_write_reg,
+	.read_reg = imx708_read_reg,
+	.parse_dt = imx708_parse_dt,
+	.power_get = imx708_power_get,
+	.power_put = imx708_power_put,
+	.set_mode = imx708_set_mode,
+	.start_streaming = imx708_start_streaming,
+	.stop_streaming = imx708_stop_streaming,
+};
+
+static int imx708_board_setup(struct imx708 *priv)
+{
+	struct camera_common_data *s_data = priv->s_data;
+	struct device *dev = s_data->dev;
+	u8 reg_val[2] = {0};
+	int err = 0;
+
+	/* Skip mclk enable as this camera has an internal oscillator */
+	err = imx708_power_on(s_data);
+	if (err) {
+		dev_err(dev, "error during power on sensor (%d)\n", err);
+		goto done;
+	}
+
+	/* Probe sensor model id registers */
+	err = imx708_read_reg(s_data, IMX708_MODEL_ID_ADDR_MSB, &reg_val[0]);
+	if (err) {
+		dev_err(dev, "%s: error during i2c read probe (%d)\n",
+			__func__, err);
+		goto err_reg_probe;
+	}
+	err = imx708_read_reg(s_data, IMX708_MODEL_ID_ADDR_LSB, &reg_val[1]);
+	if (err) {
+		dev_err(dev, "%s: error during i2c read probe (%d)\n",
+			__func__, err);
+		goto err_reg_probe;
+	}
+
+	if (!((reg_val[0] == IMX708_MODEL_ID_VALUE_MSB) &&
+		   reg_val[1] == IMX708_MODEL_ID_VALUE_LSB))
+		dev_err(dev, "%s: invalid sensor model id: %x%x\n",
+			__func__, reg_val[0], reg_val[1]);
+
+	/* Sensor fine integration time */
+	err = imx708_get_fine_integ_time(priv, &priv->fine_integ_time);
+	if (err)
+		dev_err(dev, "%s: error querying sensor fine integ. time\n",
+			__func__);
+
+err_reg_probe:
+	imx708_power_off(s_data);
+
+done:
+	return err;
+}
+
+static int imx708_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops imx708_subdev_internal_ops = {
+	.open = imx708_open,
+};
+
+static int imx708_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct tegracam_device *tc_dev = NULL;
+	struct imx708 *priv = NULL;
+	int err = 0; 
+
+	dev_dbg(dev, "probing v4l2 sensor at addr 0x%0x\n", client->addr);
+
+	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
+		return -EINVAL;
+
+	priv = devm_kzalloc(dev, sizeof(struct imx708), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	tc_dev = devm_kzalloc(dev, sizeof(struct tegracam_device), GFP_KERNEL);
+	if (!tc_dev)
+		return -ENOMEM;
+
+	priv->i2c_client = tc_dev->client = client;
+	tc_dev->dev = dev;
+	strncpy(tc_dev->name, "imx708", sizeof(tc_dev->name));
+	tc_dev->dev_regmap_config = &sensor_regmap_config;
+	tc_dev->sensor_ops = &imx708_common_ops;
+	tc_dev->v4l2sd_internal_ops = &imx708_subdev_internal_ops;
+	tc_dev->tcctrl_ops = &imx708_ctrl_ops;
+
+	err = tegracam_device_register(tc_dev);
+	if (err) {
+		dev_err(dev, "tegra camera driver registration failed\n");
+		goto register_error;
+	}
+	priv->tc_dev = tc_dev;
+	priv->s_data = tc_dev->s_data;
+	priv->subdev = &tc_dev->s_data->subdev;
+	tegracam_set_privdata(tc_dev, (void *)priv);
+
+	err = imx708_board_setup(priv);
+	if (err) {
+		dev_err(dev, "board setup failed\n");
+		goto tegracam_error;
+	}
+
+	err = tegracam_v4l2subdev_register(tc_dev, true);
+	if (err) {
+		dev_err(dev, "tegra camera subdev registration failed\n");
+		goto v4l2_error;
+	}
+
+	dev_dbg(dev, "detected imx708 sensor\n");
+
+	return 0;
+
+v4l2_error:
+	tegracam_v4l2subdev_unregister(priv->tc_dev);
+tegracam_error:
+	tegracam_device_unregister(priv->tc_dev);
+register_error:
+	return err;
+
+}
+
+
+static int imx708_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct imx708 *priv = (struct imx708 *)s_data->priv;
+
+	tegracam_v4l2subdev_unregister(priv->tc_dev);
+	tegracam_device_unregister(priv->tc_dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id imx708_id[] = {
+	{"imx708", 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, imx708_id);
+
+static struct i2c_driver imx708_i2c_driver = {
+	.driver = {
+		   .name = "imx708",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(imx708_of_match),
+		   },
+	.probe = imx708_probe,
+	.remove = imx708_remove,
+	.id_table = imx708_id,
+};
+
+module_i2c_driver(imx708_i2c_driver);
+
+MODULE_DESCRIPTION("Media Controller driver for Sony IMX708");
+MODULE_AUTHOR("RidgeRun");
+MODULE_LICENSE("GPL v2");
diff --git a/kernel/nvidia/include/media/imx708.h b/kernel/nvidia/include/media/imx708.h
new file mode 100644
index 000000000..fb888d691
--- /dev/null
+++ b/kernel/nvidia/include/media/imx708.h
@@ -0,0 +1,53 @@
+/*
+ * imx708.h - imx708 sensor header
+ *
+ * Copyright (c) 2023, RidgeRun <support@ridgerun.com>. All rights reserved.
+ *
+ * Contact us: support@ridgerun.com
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __IMX708_H__
+#define __IMX708_H__
+
+/* imx708 - sensor parameters */
+#define IMX708_MIN_GAIN		                (0)
+#define IMX708_MAX_GAIN		                (978)
+#define IMX708_ANALOG_GAIN_C0		        (516)
+#define IMX708_SHIFT_8_BITS			(8)
+#define IMX708_MIN_FRAME_LENGTH		        (256)
+#define IMX708_MAX_FRAME_LENGTH		        (65535)
+#define IMX708_MIN_COARSE_EXPOSURE	        (1)
+#define IMX708_MAX_COARSE_DIFF		        (10)
+#define IMX708_MASK_LSB_2_BITS			0x0003
+#define IMX708_MASK_LSB_8_BITS			0x00ff
+
+/* imx708 sensor register address */
+#define IMX708_MODEL_ID_ADDR_MSB		0x0000
+#define IMX708_MODEL_ID_ADDR_LSB		0x0001
+#define IMX708_MODEL_ID_VALUE_MSB		0x0003
+#define IMX708_MODEL_ID_VALUE_LSB		0x0001
+#define IMX708_ANALOG_GAIN_ADDR_MSB		0x0204
+#define IMX708_ANALOG_GAIN_ADDR_LSB		0x0205
+#define IMX708_DIGITAL_GAIN_ADDR_MSB		0x020e
+#define IMX708_DIGITAL_GAIN_ADDR_LSB		0x020f
+#define IMX708_FRAME_LENGTH_ADDR_MSB		0x0340
+#define IMX708_FRAME_LENGTH_ADDR_LSB		0x0341
+#define IMX708_COARSE_INTEG_TIME_ADDR_MSB	0x0202
+#define IMX708_COARSE_INTEG_TIME_ADDR_LSB	0x0203
+#define IMX708_FINE_INTEG_TIME_ADDR_MSB		0x0200
+#define IMX708_FINE_INTEG_TIME_ADDR_LSB		0x0201
+#define IMX708_GROUP_HOLD_ADDR		        0x0104
+
+#endif /* __IMX708_H__ */
-- 
2.34.1


