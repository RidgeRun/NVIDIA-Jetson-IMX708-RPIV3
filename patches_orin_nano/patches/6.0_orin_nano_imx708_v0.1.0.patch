From 249edacf088c14cc613cdd9653afbfe0d53202d3 Mon Sep 17 00:00:00 2001
From: David_M <david.monge@ridgerun.com>
Date: Wed, 2 Oct 2024 18:05:05 -0600
Subject: [PATCH] Squashed commit of the following:

commit cc7210a7c0ef808409681b79358b4b0eee892d8b
Author: David_M <david.monge@ridgerun.com>
Date:   Wed Oct 2 18:04:41 2024 -0600

    Delete unused data from the device tree

commit 9374d3ac41796ef8965d8f65cc0efefd3ed267b2
Author: David_M <david.monge@ridgerun.com>
Date:   Tue Oct 1 11:22:28 2024 -0600

    Remove imx219 dtsi from the overlay

commit e9e426d3eb2c7f9bc9abb871e17bcb2ab4eceb7d
Author: David_M <david.monge@ridgerun.com>
Date:   Mon Sep 30 17:33:42 2024 -0600

    Add include statement to overlay

commit 5b726760d3338fde97d085d7cca52895c72127fe
Author: David_M <david.monge@ridgerun.com>
Date:   Mon Sep 30 17:32:58 2024 -0600

    Add driver to defconfig

commit aad5021104e163fb7b15dec51bed11f33bedb3c3
Author: David_M <david.monge@ridgerun.com>
Date:   Mon Sep 30 17:32:39 2024 -0600

    Add Kconfig description

commit a57de79fff5e04a748c3cac6f09d2b03fd4e9332
Author: David_M <david.monge@ridgerun.com>
Date:   Mon Sep 30 17:31:51 2024 -0600

    Change i2c drivers Makefile

commit 6ace3fd21f58ff111b94198f380ee5907ab07216
Author: David_M <david.monge@ridgerun.com>
Date:   Mon Sep 30 17:29:19 2024 -0600

    Add modes table

commit ae347f0dbb7c05fadfb1f7761cdc3a86457c8176
Author: David_M <david.monge@ridgerun.com>
Date:   Mon Sep 30 17:28:55 2024 -0600

    Add driver and header file

commit 2697d531a6cf4171a6a2da2d4fb78e004ee0c0ea
Author: David_M <david.monge@ridgerun.com>
Date:   Mon Sep 30 17:28:24 2024 -0600

    Add dtsi files
---
 .../tegra234-camera-rpicam3-imx708.dtsi       | 278 +++++++
 ...tegra234-p3768-0000+p3767-0000-dynamic.dts |   2 +-
 .../tegra234-p3768-camera-rpicam3-imx708.dtsi |  69 ++
 .../arch/arm64/configs/defconfig              |   1 +
 .../drivers/media/i2c/Kconfig                 |   9 +
 nvidia-oot/drivers/media/i2c/Makefile         |   1 +
 .../drivers/media/i2c/imx708_mode_tbls.h      | 222 +++++
 nvidia-oot/drivers/media/i2c/nv_imx708.c      | 773 ++++++++++++++++++
 nvidia-oot/include/media/imx708.h             |  53 ++
 9 files changed, 1407 insertions(+), 1 deletion(-)
 create mode 100644 hardware/nvidia/t23x/nv-public/overlay/tegra234-camera-rpicam3-imx708.dtsi
 create mode 100644 hardware/nvidia/t23x/nv-public/overlay/tegra234-p3768-camera-rpicam3-imx708.dtsi
 create mode 100644 nvidia-oot/drivers/media/i2c/imx708_mode_tbls.h
 create mode 100644 nvidia-oot/drivers/media/i2c/nv_imx708.c
 create mode 100644 nvidia-oot/include/media/imx708.h

diff --git a/hardware/nvidia/t23x/nv-public/overlay/tegra234-camera-rpicam3-imx708.dtsi b/hardware/nvidia/t23x/nv-public/overlay/tegra234-camera-rpicam3-imx708.dtsi
new file mode 100644
index 000000000..1438d2515
--- /dev/null
+++ b/hardware/nvidia/t23x/nv-public/overlay/tegra234-camera-rpicam3-imx708.dtsi
@@ -0,0 +1,278 @@
+/*
+ * Copyright (c) 2022-2023, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2023, RidgeRun <support@ridgerun.com>. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/ {
+	fragment-camera@0 {
+		target-path = "/";
+		__overlay__ {
+			tegra-capture-vi  {
+				num-channels = <2>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					vi_port0: port@0 {
+						reg = <0>;
+						rpicam3_imx708_vi_in0: endpoint {
+							status="okay";
+							port-index = <0>;
+							bus-width = <2>;
+							remote-endpoint = <&rpicam3_imx708_csi_out0>;
+						};
+					};
+					vi_port1: port@1 {
+						reg = <1>;
+						rpicam3_imx708_vi_in1: endpoint {
+							status="okay";
+							port-index = <2>;
+							bus-width = <2>;
+							remote-endpoint = <&rpicam3_imx708_csi_out1>;
+						};
+					};
+				};
+			};
+
+			bus@0 {
+				host1x@13e00000 {
+					nvcsi@15a00000 {
+						num-channels = <2>;
+						#address-cells = <1>;
+						#size-cells = <0>;
+						csi_chan0: channel@0 {
+							reg = <0>;
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+								csi_chan0_port0: port@0 {
+									reg = <0>;
+									rpicam3_imx708_csi_in0: endpoint@0 {
+										status = "okay";
+										port-index = <1>;
+										bus-width = <2>;
+										remote-endpoint = <&rpicam3_imx708_out0>;
+									};
+								};
+								csi_chan0_port1: port@1 {
+									reg = <1>;
+									rpicam3_imx708_csi_out0: endpoint@1 {
+										status = "okay";
+										remote-endpoint = <&rpicam3_imx708_vi_in0>;
+									};
+								};
+							};
+						};
+						csi_chan1: channel@1 {
+							reg = <1>;
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+								csi_chan1_port0: port@0 {
+									reg = <0>;
+									rpicam3_imx708_csi_in1: endpoint@2 {
+										status = "okay";
+										port-index = <2>;
+										bus-width = <2>;
+										remote-endpoint = <&rpicam3_imx708_out1>;
+									};
+								};
+								csi_chan1_port1: port@1 {
+									reg = <1>;
+									rpicam3_imx708_csi_out1: endpoint@3 {
+										status = "okay";
+										remote-endpoint = <&rpicam3_imx708_vi_in1>;
+									};
+								};
+							};
+						};
+					};
+				};
+			
+				cam_i2cmux {
+					i2c_0:i2c@0 {
+						imx708_cam0: rpicam3_imx708_a@1a {
+							status = "okay";
+							compatible = "sony,imx708";
+							reg = <0x1a>;
+							devnode = "video0";
+							physical_w = "3.680";
+							physical_h = "2.760";
+							sensor_model = "imx708";
+							use_sensor_mode_id = "true";
+			
+							/* IMX708_MODE_4608x2592_14fps */
+							mode0 {
+								mclk_khz = "24000";
+								num_lanes = "2";
+								tegra_sinterface = "serial_a";
+								phy_mode = "DPHY";
+								discontinuous_clk = "yes";
+								dpcm_enable = "false";
+								cil_settletime = "0";
+								lane_polarity = "6";
+			
+								active_w = "4608";
+								active_h = "2592";
+								mode_type = "bayer";
+								pixel_phase = "rggb";
+								csi_pixel_bit_depth = "10";
+								readout_orientation = "90";
+								line_length = "4808";
+								inherent_gain = "1";
+								pix_clk_hz = "297600000"; 
+			
+								gain_factor = "16";
+								framerate_factor = "1000000";
+								exposure_factor = "1000000";
+								min_gain_val = "16"; 
+								max_gain_val = "256"; 
+								step_gain_val = "1";
+								default_gain = "16";
+								min_hdr_ratio = "1";
+								max_hdr_ratio = "1";
+								min_framerate = "2000000";
+								max_framerate = "14000000";
+								step_framerate = "1";
+								default_framerate = "14000000";
+								min_exp_time = "500";
+								max_exp_time = "65487";
+								step_exp_time = "1";
+								default_exp_time = "1600";
+								embedded_metadata_height = "4";
+							};
+			
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+			
+								port@0 {
+									reg = <0>;
+									rpicam3_imx708_out0: endpoint {
+										port-index = <0>;
+										bus-width = <2>;
+										remote-endpoint = <&rpicam3_imx708_csi_in0>;
+									};
+								};
+							};
+						};
+					};
+					i2c_1: i2c@1 {
+						imx708_cam1: rpicam3_imx708_c@1a {
+							status = "okay";
+							compatible = "sony,imx708";
+							reg = <0x1a>;
+							devnode = "video1";
+							physical_w = "3.680";
+							physical_h = "2.760";
+							sensor_model = "imx708";
+							use_sensor_mode_id = "true";
+			
+							/* IMX708_MODE_4608x2592_14fps */
+							mode0 {
+								mclk_khz = "24000";
+								num_lanes = "2";
+								tegra_sinterface = "serial_c";
+								phy_mode = "DPHY";
+								discontinuous_clk = "yes";
+								dpcm_enable = "false";
+								cil_settletime = "0";
+								lane_polarity = "0";
+			
+								active_w = "4608";
+								active_h = "2592";
+								mode_type = "bayer";
+								pixel_phase = "rggb";
+								csi_pixel_bit_depth = "10";
+								readout_orientation = "90";
+								line_length = "4808";
+								inherent_gain = "1";
+								pix_clk_hz = "297600000";
+			
+								gain_factor = "16";
+								framerate_factor = "1000000";
+								exposure_factor = "1000000";
+								min_gain_val = "16"; 
+								max_gain_val = "256"; 
+								step_gain_val = "1";
+								default_gain = "16";
+								min_hdr_ratio = "1";
+								max_hdr_ratio = "1";
+								min_framerate = "2000000";
+								max_framerate = "14000000";
+								step_framerate = "1";
+								default_framerate = "14000000";
+								min_exp_time = "500";
+								max_exp_time = "65487";
+								step_exp_time = "1";
+								default_exp_time = "1600";
+								embedded_metadata_height = "4";
+							};
+			
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+			
+								port@0 {
+									reg = <0>;
+									rpicam3_imx708_out1: endpoint {
+										status = "okay";
+										port-index = <2>;
+										bus-width = <2>;
+										remote-endpoint = <&rpicam3_imx708_csi_in1>;
+									};
+								};
+							};
+						};
+					};
+				};
+			};
+
+			tcp: tegra-camera-platform {
+				compatible = "nvidia, tegra-camera-platform";
+				num_csi_lanes = <4>;
+				max_lane_speed = <2500000>;
+				min_bits_per_pixel = <10>;
+				vi_peak_byte_per_pixel = <2>;
+				vi_bw_margin_pct = <25>;
+				max_pixel_rate = <7500000>;
+				isp_peak_byte_per_pixel = <5>;
+				isp_bw_margin_pct = <25>;
+		
+				modules {
+					cam_module0: module0 {
+						status = "okay";
+						badge = "jakku_front_RBPCV3";
+						position = "front";
+						orientation = "1";
+						cam_module0_drivernode0: drivernode0 {
+							pcl_id = "v4l2_sensor";
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/cam_i2cmux/i2c@0/rpicam3_imx708_a@1a";
+						};
+					};
+					cam_module1: module1 {
+						badge = "jakku_rear_RBPCV3";
+						position = "rear";
+						orientation = "1";
+						cam_module1_drivernode0: drivernode0 {
+							pcl_id = "v4l2_sensor";
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/cam_i2cmux/i2c@1/rpicam3_imx708_c@1a";
+						};
+					};
+				};
+			};
+		};
+	};
+};
diff --git a/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3768-0000+p3767-0000-dynamic.dts b/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3768-0000+p3767-0000-dynamic.dts
index b9fed3958..3350ae3df 100644
--- a/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3768-0000+p3767-0000-dynamic.dts
+++ b/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3768-0000+p3767-0000-dynamic.dts
@@ -4,7 +4,7 @@
 /dts-v1/;
 /plugin/;
 
-#include "tegra234-p3768-camera-rbpcv2-imx219.dtsi"
+#include "tegra234-p3768-camera-rpicam3-imx708.dtsi"
 
 / {
 	overlay-name = "Tegra234 p3768-0000+p3767-xxxx Dynamic Overlay";
diff --git a/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3768-camera-rpicam3-imx708.dtsi b/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3768-camera-rpicam3-imx708.dtsi
new file mode 100644
index 000000000..2cf415df9
--- /dev/null
+++ b/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3768-camera-rpicam3-imx708.dtsi
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2022, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2023, RidgeRun.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <dt-bindings/tegra234-p3767-0000-common.h>
+#include "tegra234-camera-rpicam3-imx708.dtsi"
+
+#define CAM0_RST        TEGRA234_MAIN_GPIO(H, 3)
+#define CAM0_PWDN	TEGRA234_MAIN_GPIO(H, 6)
+#define CAM1_PWDN	TEGRA234_MAIN_GPIO(AC, 0)
+#define CAM_I2C_MUX 	TEGRA234_AON_GPIO(CC, 3)
+
+/ {
+	fragment-camera-imx708@0 {
+		target-path = "/";
+		__overlay__ {
+			bus@0 {
+				cam_i2cmux {
+					status = "okay";
+					compatible = "i2c-mux-gpio";
+					#address-cells = <1>;
+					#size-cells = <0>;
+					mux-gpios = <&gpio_aon CAM_I2C_MUX GPIO_ACTIVE_HIGH>;
+					i2c-parent = <&cam_i2c>;
+					i2c@0 {
+						reg = <0>;
+						#address-cells = <1>;
+						#size-cells = <0>;
+						rpicam3_imx708_a@1a {
+							reset-gpios = <&gpio CAM0_PWDN GPIO_ACTIVE_HIGH>;
+						};
+					};
+					i2c@1 {
+						status = "okay";
+						reg = <1>;
+						#address-cells = <1>;
+						#size-cells = <0>;
+						rpicam3_imx708_c@1a {
+							reset-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
+						};
+					};
+				};
+
+				gpio@2200000 {
+					camera-control-output-low {
+						gpio-hog;
+						output-low;
+						gpios = <CAM0_RST 0>;
+						label = "cam0-rst";
+					};
+				};
+			};
+		};
+	};
+};
diff --git a/kernel/kernel-jammy-src/arch/arm64/configs/defconfig b/kernel/kernel-jammy-src/arch/arm64/configs/defconfig
index 57e2a364e..bebf12dc8 100644
--- a/kernel/kernel-jammy-src/arch/arm64/configs/defconfig
+++ b/kernel/kernel-jammy-src/arch/arm64/configs/defconfig
@@ -1329,3 +1329,4 @@ CONFIG_FUNCTION_TRACER=y
 # CONFIG_FUNCTION_GRAPH_TRACER is not set
 # CONFIG_DYNAMIC_FTRACE is not set
 CONFIG_MEMTEST=y
+CONFIG_NV_VIDEO_IMX708=m
diff --git a/kernel/kernel-jammy-src/drivers/media/i2c/Kconfig b/kernel/kernel-jammy-src/drivers/media/i2c/Kconfig
index 67b15c24e..04cb16c38 100644
--- a/kernel/kernel-jammy-src/drivers/media/i2c/Kconfig
+++ b/kernel/kernel-jammy-src/drivers/media/i2c/Kconfig
@@ -883,6 +883,15 @@ config VIDEO_IMX412
 	  To compile this driver as a module, choose M here: the
 	  module will be called imx412.
 
+config NV_VIDEO_IMX708
+        tristate "Sony IMX708 sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	  This driver supports IMX708 camera sensor from Sony
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called IMX708.
+
 config VIDEO_OV02A10
 	tristate "OmniVision OV02A10 sensor support"
 	depends on VIDEO_V4L2 && I2C
diff --git a/nvidia-oot/drivers/media/i2c/Makefile b/nvidia-oot/drivers/media/i2c/Makefile
index 7c5913c64..0ba7d6e5e 100644
--- a/nvidia-oot/drivers/media/i2c/Makefile
+++ b/nvidia-oot/drivers/media/i2c/Makefile
@@ -17,6 +17,7 @@ obj-m += nv_imx274.o
 obj-m += nv_imx318.o
 obj-m += nv_imx390.o
 obj-m += nv_imx477.o
+obj-$(CONFIG_NV_VIDEO_IMX708) += nv_imx708.o
 obj-m += nv_ov5693.o
 obj-m += nv_ar0234.o
 obj-m += nv_hawk_owl.o
diff --git a/nvidia-oot/drivers/media/i2c/imx708_mode_tbls.h b/nvidia-oot/drivers/media/i2c/imx708_mode_tbls.h
new file mode 100644
index 000000000..7d975066e
--- /dev/null
+++ b/nvidia-oot/drivers/media/i2c/imx708_mode_tbls.h
@@ -0,0 +1,222 @@
+/*
+ * Copyright (c) 2020-2023, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (C) 2022, Raspberry Pi Ltd
+ * Copyright (c) 2023, RidgeRun <support@ridgerun.com>. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __IMX708_I2C_TABLES__
+#define __IMX708_I2C_TABLES__
+
+#include <media/camera_common.h>
+
+#define IMX708_TABLE_WAIT_MS 0
+#define IMX708_TABLE_END 1
+#define IMX708_WAIT_MS 1
+#define IMX708_STANDBY_REG 0x0100
+
+#define imx708_reg struct reg_8
+
+static const imx708_reg imx708_start[] = {
+	{IMX708_STANDBY_REG, 0x1},
+	{IMX708_TABLE_WAIT_MS, IMX708_WAIT_MS*3},
+	{IMX708_TABLE_END, 0x00}
+};
+
+static const imx708_reg imx708_stop[] = {
+	{IMX708_STANDBY_REG, 0x0},
+	{IMX708_TABLE_END, 0x00}
+};
+
+static const imx708_reg imx708_mode_common[] = {
+	/* software reset */
+	{0x0103, 0x01},
+	{IMX708_TABLE_WAIT_MS, IMX708_WAIT_MS*10},
+	{0x0100, 0x00},
+	{0x0136, 0x18},
+	{0x0137, 0x00},
+	{0x33F0, 0x02},
+	{0x33F1, 0x05},
+	{0x3062, 0x00},
+	{0x3063, 0x12},
+	{0x3068, 0x00},
+	{0x3069, 0x12},
+	{0x306A, 0x00},
+	{0x306B, 0x30},
+	{0x3076, 0x00},
+	{0x3077, 0x30},
+	{0x3078, 0x00},
+	{0x3079, 0x30},
+	{0x5E54, 0x0C},
+	{0x6E44, 0x00},
+	{0xB0B6, 0x01},
+	{0xE829, 0x00},
+	{0xF001, 0x08},
+	{0xF003, 0x08},
+	{0xF00D, 0x10},
+	{0xF00F, 0x10},
+	{0xF031, 0x08},
+	{0x0830, 0x01},
+	{0x0831, 0x01}, 
+	{0x0832, 0x01},
+	{0xF033, 0x08},
+	{0xF03D, 0x10},
+	{0xF03F, 0x10},
+	{0x0112, 0x0a},
+	{0x0113, 0x0a},
+	{0x0114, 0x01},
+	{0x0B8E, 0x01},
+	{0x0B8F, 0x00},
+	{0x0B94, 0x01},
+	{0x0B95, 0x00},
+	{0x3400, 0x01},
+	{0x3478, 0x01},
+	{0x3479, 0x1c},
+	{0x3091, 0x01},
+	{0x3092, 0x00},
+	{0x3419, 0x00},
+	{0xBCF1, 0x02},
+	{0x3094, 0x01},
+	{0x3095, 0x01},
+	{0x3362, 0x00},
+	{0x3363, 0x00},
+	{0x3364, 0x00},
+	{0x3365, 0x00},
+	{0x0138, 0x01},
+	{IMX708_TABLE_END, 0x0000}
+};
+
+static const imx708_reg imx708_mode_4608x2592_14fps[] = {
+	{0x0342, 0x3D},
+	{0x0343, 0x20},
+	{0x0340, 0x0A},
+	{0x0341, 0x5a},
+	{0x0344, 0x00},
+	{0x0345, 0x00},
+	{0x0346, 0x00},
+	{0x0347, 0x00},
+	{0x0348, 0x11},
+	{0x0349, 0xFF},
+	{0x034A, 0X0A},
+	{0x034B, 0x1F},
+	{0x0220, 0x62},
+	{0x0222, 0x01},
+	{0x0900, 0x00},
+	{0x0901, 0x11},
+	{0x0902, 0x0A},
+	{0x3200, 0x01},
+	{0x3201, 0x01},
+	{0x32D5, 0x01},
+	{0x32D6, 0x00},
+	{0x32DB, 0x01},
+	{0x32DF, 0x00},
+	{0x350C, 0x00},
+	{0x350D, 0x00},
+	{0x0408, 0x00},
+	{0x0409, 0x00},
+	{0x040A, 0x00},
+	{0x040B, 0x00},
+	{0x040C, 0x12},
+	{0x040D, 0x00},
+	{0x040E, 0x0A},
+	{0x040F, 0x20},
+	{0x034C, 0x12},
+	{0x034D, 0x00},
+	{0x034E, 0x0A},
+	{0x034F, 0x20},
+	{0x0301, 0x05},
+	{0x0303, 0x02},
+	{0x0305, 0x02},
+	{0x0306, 0x00},
+	{0x0307, 0x7C},
+	{0x030B, 0x02},
+	{0x030D, 0x04},
+	{0x030E, 0x01},
+	{0x030F, 0x2C},
+	{0x0310, 0x01},
+	{0x3CA0, 0x00},
+	{0x3CA1, 0x64},
+	{0x3CA4, 0x00},
+	{0x3CA5, 0x00},
+	{0x3CA6, 0x00},
+	{0x3CA7, 0x00},
+	{0x3CAA, 0x00},
+	{0x3CAB, 0x00},
+	{0x3CB8, 0x00},
+	{0x3CB9, 0x08},
+	{0x3CBA, 0x00},
+	{0x3CBB, 0x00},
+	{0x3CBC, 0x00},
+	{0x3CBD, 0x3C},
+	{0x3CBE, 0x00},
+	{0x3CBF, 0x00},
+	{0x0202, 0x0A},
+	{0x0203, 0x2a},
+	{0x0224, 0x01},
+	{0x0225, 0xF4},
+	{0x3116, 0x01},
+	{0x3117, 0xF4},
+	{0x0204, 0x03},
+	{0x0205, 0x55},
+	{0x0216, 0x00},
+	{0x0217, 0x00},
+	{0x0218, 0x01},
+	{0x0219, 0x00},
+	{0x020E, 0x01},
+	{0x020F, 0x00},
+	{0x3118, 0x00},
+	{0x3119, 0x00},
+	{0x311A, 0x01},
+	{0x311B, 0x00},
+	{0x341a, 0x00},
+	{0x341b, 0x00},
+	{0x341c, 0x00},
+	{0x341d, 0x00},
+	{0x341e, 0x01},
+	{0x341f, 0x20},
+	{0x3420, 0x00},
+	{0x3421, 0xd8},
+	{0xC428, 0x00},
+	{0xC429, 0x04},
+	{0x3366, 0x00},
+	{0x3367, 0x00},
+	{0x3368, 0x00},
+	{0x3369, 0x00},
+	{IMX708_TABLE_WAIT_MS, IMX708_WAIT_MS},
+	{IMX708_TABLE_END, 0x0000}
+};
+
+enum {
+	IMX708_MODE_4608x2592_14FPS,
+	IMX708_MODE_COMMON,
+	IMX708_START_STREAM,
+	IMX708_STOP_STREAM,
+};
+
+static const imx708_reg *mode_table[] = {
+	[IMX708_MODE_4608x2592_14FPS] = imx708_mode_4608x2592_14fps,
+	[IMX708_MODE_COMMON] = imx708_mode_common,
+	[IMX708_START_STREAM] = imx708_start,
+	[IMX708_STOP_STREAM] = imx708_stop,
+};
+
+static const int imx708_14_fr[] = {
+	14,
+};
+
+static const struct camera_common_frmfmt imx708_frmfmt[] = {
+	{{4608, 2592}, imx708_14_fr, 1, 0, IMX708_MODE_4608x2592_14FPS},
+};
+#endif
diff --git a/nvidia-oot/drivers/media/i2c/nv_imx708.c b/nvidia-oot/drivers/media/i2c/nv_imx708.c
new file mode 100644
index 000000000..4db5a7b54
--- /dev/null
+++ b/nvidia-oot/drivers/media/i2c/nv_imx708.c
@@ -0,0 +1,773 @@
+/*
+ * imx708.c - imx708 sensor driver
+ *
+ * Copyright (c) 2021-2023, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2023, RidgeRun <support@ridgerun.com>. All rights reserved.
+ *
+ * Contact us: support@ridgerun.com
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <media/tegra_v4l2_camera.h>
+#include <media/tegracam_core.h>
+#include <media/imx708.h>
+
+#include "../platform/tegra/camera/camera_gpio.h"
+#include "imx708_mode_tbls.h"
+
+static const struct of_device_id imx708_of_match[] = {
+	{.compatible = "sony,imx708",},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, imx708_of_match);
+
+static const u32 ctrl_cid_list[] = {
+	TEGRA_CAMERA_CID_GAIN,
+	TEGRA_CAMERA_CID_EXPOSURE,
+	TEGRA_CAMERA_CID_FRAME_RATE,
+	TEGRA_CAMERA_CID_SENSOR_MODE_ID,
+};
+
+struct imx708 {
+	struct i2c_client *i2c_client;
+	struct v4l2_subdev *subdev;
+	u16 fine_integ_time;
+	u32 frame_length;
+	struct camera_common_data *s_data;
+	struct tegracam_device *tc_dev;
+};
+
+static const struct regmap_config sensor_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+#if KERNEL_VERSION(5, 4, 0) > LINUX_VERSION_CODE
+		.use_single_rw = true,
+#else
+		.use_single_read = true,
+		.use_single_write = true,
+#endif
+};
+
+static inline void imx708_get_frame_length_regs(imx708_reg * regs,
+						u32 frame_length)
+{
+	regs->addr = IMX708_FRAME_LENGTH_ADDR_MSB;
+	regs->val = (frame_length >> 8) & 0xff;
+	(regs + 1)->addr = IMX708_FRAME_LENGTH_ADDR_LSB;
+	(regs + 1)->val = (frame_length) & 0xff;
+}
+
+static inline void imx708_get_coarse_integ_time_regs(imx708_reg * regs,
+						     u32 coarse_time)
+{
+	regs->addr = IMX708_COARSE_INTEG_TIME_ADDR_MSB;
+	regs->val = (coarse_time >> 8) & 0xff;
+	(regs + 1)->addr = IMX708_COARSE_INTEG_TIME_ADDR_LSB;
+	(regs + 1)->val = (coarse_time) & 0xff;
+}
+
+static inline void imx708_get_gain_reg(imx708_reg * reg, u16 gain)
+{
+	reg->addr = IMX708_ANALOG_GAIN_ADDR_MSB;
+	reg->val = (gain >> IMX708_SHIFT_8_BITS) & IMX708_MASK_LSB_2_BITS;
+
+	(reg + 1)->addr = IMX708_ANALOG_GAIN_ADDR_LSB;
+	(reg + 1)->val = (gain) & IMX708_MASK_LSB_8_BITS;
+}
+
+static inline int imx708_read_reg(struct camera_common_data *s_data,
+				  u16 addr, u8 * val)
+{
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(s_data->regmap, addr, &reg_val);
+	*val = reg_val & 0xff;
+
+	return err;
+}
+
+static inline int imx708_write_reg(struct camera_common_data *s_data,
+				   u16 addr, u8 val)
+{
+	int err = 0;
+
+	err = regmap_write(s_data->regmap, addr, val);
+	if (err)
+		dev_err(s_data->dev, "%s: i2c write failed, 0x%x = %x",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int imx708_write_table(struct imx708 *priv, const imx708_reg table[])
+{
+	return regmap_util_write_table_8(priv->s_data->regmap, table, NULL, 0,
+					 IMX708_TABLE_WAIT_MS,
+					 IMX708_TABLE_END);
+}
+
+static int imx708_set_group_hold(struct tegracam_device *tc_dev, bool val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct device *dev = tc_dev->dev;
+	int err = 0;
+
+	dev_dbg(dev, "%s: Setting group hold control to: %u\n", __func__, val);
+
+	err = imx708_write_reg(s_data, IMX708_GROUP_HOLD_ADDR, val);
+	if (err) {
+		dev_err(dev, "%s: Group hold control error\n", __func__);
+		return err;
+	}
+
+	return 0;
+}
+
+static int imx708_get_fine_integ_time(struct imx708 *priv, u16 * fine_time)
+{
+	struct camera_common_data *s_data = priv->s_data;
+	int err = 0;
+	u8 reg_val[2] = {0};
+
+	err = imx708_read_reg(s_data, IMX708_FINE_INTEG_TIME_ADDR_MSB,
+			      &reg_val[0]);
+	if (err)
+		goto done;
+
+	err = imx708_read_reg(s_data, IMX708_FINE_INTEG_TIME_ADDR_LSB,
+			      &reg_val[1]);
+	if (err)
+		goto done;
+
+	*fine_time = (reg_val[0] << 8) | reg_val[1];
+
+done:
+	return err;
+}
+
+static int imx708_set_gain(struct tegracam_device *tc_dev, s64 val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct device *dev = s_data->dev;
+	const struct sensor_mode_properties *mode =
+	    &s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+	int err = 0; 
+	int i = 0;
+	imx708_reg gain_reg[2] = {0};
+	s16 gain = 0;
+
+	dev_dbg(dev, "%s: Setting gain control to: %lld\n", __func__, val);
+
+	/* Gain Formula:
+	   Gain = (IMX708_GAIN_C0 - (IMX708_GAIN_C0 * gain_factor / val))
+	 */
+	gain =
+	    (s16) (IMX708_ANALOG_GAIN_C0 -
+		   (mode->control_properties.gain_factor *
+		    IMX708_ANALOG_GAIN_C0 / val));
+
+	dev_dbg(dev, "%s: val: %lld (/%d) [times], gain: %u\n",
+		__func__, val, mode->control_properties.gain_factor, gain);
+
+	imx708_get_gain_reg(gain_reg, (u16) gain);
+
+	for (i = 0; i < ARRAY_SIZE(gain_reg); i++) {
+		err = imx708_write_reg(s_data, gain_reg[i].addr,
+				       gain_reg[i].val);
+		if (err) {
+			dev_err(dev, "%s: gain control error\n", __func__);
+			break;
+		}
+	}
+
+	return err;
+}
+
+static int imx708_set_frame_rate(struct tegracam_device *tc_dev, s64 val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct imx708 *priv = (struct imx708 *)tc_dev->priv;
+	struct device *dev = tc_dev->dev;
+	const struct sensor_mode_properties *mode =
+	    &s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+
+	int err = 0;
+	imx708_reg fl_regs[2] = {0};
+	u32 frame_length = 0;
+	int i = 0;
+
+	dev_dbg(dev, "%s: Setting framerate control to: %lld\n", __func__, val);
+
+	frame_length = (u32)(mode->signal_properties.pixel_clock.val *
+		(u64)mode->control_properties.framerate_factor /
+		mode->image_properties.line_length / val);
+
+	dev_dbg(dev,
+		"%s: val: %llde-6 [fps], frame_length: %u [lines]\n",
+		__func__, val, frame_length);
+
+	imx708_get_frame_length_regs(fl_regs, frame_length);
+	for (i = 0; i < 2; i++) {
+		err = imx708_write_reg(s_data, fl_regs[i].addr, fl_regs[i].val);
+		if (err) {
+			dev_err(dev,
+				"%s: frame_length control error\n", __func__);
+			return err;
+		}
+	}
+
+	priv->frame_length = frame_length;
+
+	return err;
+}
+
+static int imx708_set_exposure(struct tegracam_device *tc_dev, s64 val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct imx708 *priv = (struct imx708 *)tc_dev->priv;
+	struct device *dev = tc_dev->dev;
+	const struct sensor_mode_properties *mode =
+	    &s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+
+	int err = 0;
+	imx708_reg ct_regs[2] = {0};
+	const s32 fine_integ_time_factor = priv->fine_integ_time *
+	    mode->control_properties.exposure_factor /
+	    mode->signal_properties.pixel_clock.val;
+	u32 coarse_time = 0;
+	int i = 0;
+
+	dev_dbg(dev, "%s: Setting exposure control to: %lld\n", __func__, val);
+
+	coarse_time = (val - fine_integ_time_factor)
+	    * mode->signal_properties.pixel_clock.val
+	    / mode->control_properties.exposure_factor
+	    / mode->image_properties.line_length;
+
+	dev_dbg(dev, "%s: val: %lld [us], coarse_time: %d [lines]\n",
+		__func__, val, coarse_time);
+
+	imx708_get_coarse_integ_time_regs(ct_regs, coarse_time);
+
+	for (i = 0; i < 2; i++) {
+		err = imx708_write_reg(s_data, ct_regs[i].addr, ct_regs[i].val);
+		if (err) {
+			dev_err(dev,
+				"%s: coarse_time control error\n", __func__);
+			return err;
+		}
+	}
+
+	return err;
+}
+
+static struct tegracam_ctrl_ops imx708_ctrl_ops = {
+	.numctrls = ARRAY_SIZE(ctrl_cid_list),
+	.ctrl_cid_list = ctrl_cid_list,
+	.set_gain = imx708_set_gain,
+	.set_exposure = imx708_set_exposure,
+	.set_frame_rate = imx708_set_frame_rate,
+	.set_group_hold = imx708_set_group_hold,
+};
+
+static int imx708_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+
+	dev_dbg(dev, "%s: power on\n", __func__);
+	if (pdata && pdata->power_on) {
+		err = pdata->power_on(pw);
+		if (err)
+			dev_err(dev, "%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+
+	if (pw->reset_gpio) {
+		if (gpio_cansleep(pw->reset_gpio))
+			gpio_set_value_cansleep(pw->reset_gpio, 0);
+		else
+			gpio_set_value(pw->reset_gpio, 0);
+	}
+
+	if (unlikely(!(pw->avdd || pw->iovdd || pw->dvdd)))
+		goto skip_power_seqn;
+
+	usleep_range(10, 20);
+
+	if (pw->avdd) {
+		err = regulator_enable(pw->avdd);
+		if (err)
+			goto imx708_avdd_fail;
+	}
+
+	if (pw->iovdd) {
+		err = regulator_enable(pw->iovdd);
+		if (err)
+			goto imx708_iovdd_fail;
+	}
+
+	if (pw->dvdd) {
+		err = regulator_enable(pw->dvdd);
+		if (err)
+			goto imx708_dvdd_fail;
+	}
+
+	usleep_range(10, 20);
+
+skip_power_seqn:
+	if (pw->reset_gpio) {
+		if (gpio_cansleep(pw->reset_gpio))
+			gpio_set_value_cansleep(pw->reset_gpio, 1);
+		else
+			gpio_set_value(pw->reset_gpio, 1);
+	}
+
+	/* Need to wait for t4 + t5 + t9 + t10 time as per the data sheet */
+	/* t4 - 200us, t5 - 21.2ms, t9 - 1.2ms t10 - 270 ms */
+	usleep_range(300000, 300100);
+
+	pw->state = SWITCH_ON;
+
+	return 0;
+
+imx708_dvdd_fail:
+	regulator_disable(pw->iovdd);
+
+imx708_iovdd_fail:
+	regulator_disable(pw->avdd);
+
+imx708_avdd_fail:
+	dev_err(dev, "%s failed.\n", __func__);
+
+	return -ENODEV;
+}
+
+static int imx708_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+
+	dev_dbg(dev, "%s: power off\n", __func__);
+
+	if (pdata && pdata->power_off) {
+		err = pdata->power_off(pw);
+		if (err) {
+			dev_err(dev, "%s failed.\n", __func__);
+			return err;
+		}
+	} else {
+		if (pw->reset_gpio) {
+			if (gpio_cansleep(pw->reset_gpio))
+				gpio_set_value_cansleep(pw->reset_gpio, 0);
+			else
+				gpio_set_value(pw->reset_gpio, 0);
+		}
+
+		usleep_range(10, 10);
+
+		if (pw->dvdd)
+			regulator_disable(pw->dvdd);
+		if (pw->iovdd)
+			regulator_disable(pw->iovdd);
+		if (pw->avdd)
+			regulator_disable(pw->avdd);
+	}
+
+	pw->state = SWITCH_OFF;
+
+	return 0;
+}
+
+static int imx708_power_put(struct tegracam_device *tc_dev)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+
+	if (unlikely(!pw))
+		return -EFAULT;
+
+	if (likely(pw->dvdd))
+		devm_regulator_put(pw->dvdd);
+
+	if (likely(pw->avdd))
+		devm_regulator_put(pw->avdd);
+
+	if (likely(pw->iovdd))
+		devm_regulator_put(pw->iovdd);
+
+	pw->dvdd = NULL;
+	pw->avdd = NULL;
+	pw->iovdd = NULL;
+
+	if (likely(pw->reset_gpio))
+		gpio_free(pw->reset_gpio);
+
+	return 0;
+}
+
+static int imx708_power_get(struct tegracam_device *tc_dev)
+{
+	struct device *dev = tc_dev->dev;
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct clk *parent;
+	int err = 0;
+
+	if (!pdata) {
+		dev_err(dev, "pdata missing\n");
+		return -EFAULT;
+	}
+
+	/* Sensor MCLK (aka. INCK) */
+	if (pdata->mclk_name) {
+		pw->mclk = devm_clk_get(dev, pdata->mclk_name);
+		if (IS_ERR(pw->mclk)) {
+			dev_err(dev, "unable to get clock %s\n",
+				pdata->mclk_name);
+			return PTR_ERR(pw->mclk);
+		}
+
+		if (pdata->parentclk_name) {
+			parent = devm_clk_get(dev, pdata->parentclk_name);
+			if (IS_ERR(parent)) {
+				dev_err(dev, "unable to get parent clock %s",
+					pdata->parentclk_name);
+			} else
+				clk_set_parent(pw->mclk, parent);
+		}
+	}
+
+	/* analog 2.8v */
+	if (pdata->regulators.avdd)
+		err |= camera_common_regulator_get(dev,
+						   &pw->avdd,
+						   pdata->regulators.avdd);
+	/* IO 1.8v */
+	if (pdata->regulators.iovdd)
+		err |= camera_common_regulator_get(dev,
+						   &pw->iovdd,
+						   pdata->regulators.iovdd);
+	/* dig 1.2v */
+	if (pdata->regulators.dvdd)
+		err |= camera_common_regulator_get(dev,
+						   &pw->dvdd,
+						   pdata->regulators.dvdd);
+	if (err) {
+		dev_err(dev, "%s: unable to get regulator(s)\n", __func__);
+		goto done;
+	}
+
+	/* Reset or ENABLE GPIO */
+
+	pw->reset_gpio = pdata->reset_gpio;
+	err = gpio_request(pw->reset_gpio, "cam_reset_gpio");
+	if (err < 0) {
+		dev_err(dev, "%s: unable to request reset_gpio (%d)\n",
+			__func__, err);
+		goto done;
+	}
+
+done:
+	pw->state = SWITCH_OFF;
+
+	return err;
+}
+
+static struct camera_common_pdata *imx708_parse_dt(struct tegracam_device
+						   *tc_dev)
+{
+	struct device *dev = tc_dev->dev;
+	struct device_node *np = dev->of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	struct camera_common_pdata *ret = NULL;
+	int err = 0;
+	int gpio = 0;
+
+	if (!np)
+		return NULL;
+
+	match = of_match_device(imx708_of_match, dev);
+	if (!match) {
+		dev_err(dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	board_priv_pdata = devm_kzalloc(dev,
+					sizeof(*board_priv_pdata), GFP_KERNEL);
+	if (!board_priv_pdata)
+		return NULL;
+
+	gpio = of_get_named_gpio(np, "reset-gpios", 0);
+	if (gpio < 0) {
+		if (gpio == -EPROBE_DEFER)
+			ret = ERR_PTR(-EPROBE_DEFER);
+		dev_err(dev, "reset-gpios not found\n");
+		goto error;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+
+	err = of_property_read_string(np, "avdd-reg",
+				      &board_priv_pdata->regulators.avdd);
+	err |= of_property_read_string(np, "iovdd-reg",
+				       &board_priv_pdata->regulators.iovdd);
+	err |= of_property_read_string(np, "dvdd-reg",
+				       &board_priv_pdata->regulators.dvdd);
+	if (err)
+		dev_dbg(dev, "avdd, iovdd and/or dvdd reglrs. not present, "
+			"assume sensor powered independently\n");
+
+	board_priv_pdata->has_eeprom = of_property_read_bool(np, "has-eeprom");
+
+	return board_priv_pdata;
+
+error:
+	devm_kfree(dev, board_priv_pdata);
+
+	return ret;
+}
+
+static int imx708_set_mode(struct tegracam_device *tc_dev)
+{
+	struct imx708 *priv = (struct imx708 *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = tc_dev->s_data;
+
+	int err = 0;
+
+	err = imx708_write_table(priv, mode_table[IMX708_MODE_COMMON]);
+	if (err)
+	{
+		dev_err(tc_dev->dev, "failed writing common mode err:%d\n", err);
+		return err;
+	}
+
+	if (s_data->mode < 0)
+		return -EINVAL;
+	err = imx708_write_table(priv, mode_table[s_data->mode]);
+	if (err)
+	{
+		dev_err(tc_dev->dev, "failed to write mode %d  err:%d\n", s_data->mode, err);
+		return err;
+	}
+	
+	return 0;
+}
+
+
+static int imx708_start_streaming(struct tegracam_device *tc_dev)
+{
+	struct imx708 *priv = (struct imx708 *)tegracam_get_privdata(tc_dev);
+
+	dev_dbg(tc_dev->dev, "%s:\n", __func__);
+
+	return imx708_write_table(priv, mode_table[IMX708_START_STREAM]);
+}
+
+static int imx708_stop_streaming(struct tegracam_device *tc_dev)
+{
+	int err = 0;
+
+	struct imx708 *priv = (struct imx708 *)tegracam_get_privdata(tc_dev);
+
+	dev_dbg(tc_dev->dev, "%s:\n", __func__);
+
+	err = imx708_write_table(priv, mode_table[IMX708_STOP_STREAM]);
+
+	return err;
+}
+
+static struct camera_common_sensor_ops imx708_common_ops = {
+	.numfrmfmts = ARRAY_SIZE(imx708_frmfmt),
+	.frmfmt_table = imx708_frmfmt,
+	.power_on = imx708_power_on,
+	.power_off = imx708_power_off,
+	.write_reg = imx708_write_reg,
+	.read_reg = imx708_read_reg,
+	.parse_dt = imx708_parse_dt,
+	.power_get = imx708_power_get,
+	.power_put = imx708_power_put,
+	.set_mode = imx708_set_mode,
+	.start_streaming = imx708_start_streaming,
+	.stop_streaming = imx708_stop_streaming,
+};
+
+static int imx708_board_setup(struct imx708 *priv)
+{
+	struct camera_common_data *s_data = priv->s_data;
+	struct device *dev = s_data->dev;
+	u8 reg_val[2] = {0};
+	int err = 0;
+
+	/* Skip mclk enable as this camera has an internal oscillator */
+	err = imx708_power_on(s_data);
+	if (err) {
+		dev_err(dev, "error during power on sensor (%d)\n", err);
+		goto done;
+	}
+
+	/* Probe sensor model id registers */
+	err = imx708_read_reg(s_data, IMX708_MODEL_ID_ADDR_MSB, &reg_val[0]);
+	if (err) {
+		dev_err(dev, "%s: error during i2c read probe (%d)\n",
+			__func__, err);
+		goto err_reg_probe;
+	}
+	err = imx708_read_reg(s_data, IMX708_MODEL_ID_ADDR_LSB, &reg_val[1]);
+	if (err) {
+		dev_err(dev, "%s: error during i2c read probe (%d)\n",
+			__func__, err);
+		goto err_reg_probe;
+	}
+
+	if (!((reg_val[0] == IMX708_MODEL_ID_VALUE_MSB) &&
+		   reg_val[1] == IMX708_MODEL_ID_VALUE_LSB))
+		dev_err(dev, "%s: invalid sensor model id: %x%x\n",
+			__func__, reg_val[0], reg_val[1]);
+
+	/* Sensor fine integration time */
+	err = imx708_get_fine_integ_time(priv, &priv->fine_integ_time);
+	if (err)
+		dev_err(dev, "%s: error querying sensor fine integ. time\n",
+			__func__);
+
+err_reg_probe:
+	imx708_power_off(s_data);
+
+done:
+	return err;
+}
+
+static int imx708_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	dev_dbg(&client->dev, "%s:\n", __func__);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops imx708_subdev_internal_ops = {
+	.open = imx708_open,
+};
+
+static int imx708_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct tegracam_device *tc_dev = NULL;
+	struct imx708 *priv = NULL;
+	int err = 0; 
+
+	dev_err(dev, "probing v4l2 sensor at addr 0x%0x\n", client->addr);
+
+	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
+		return -EINVAL;
+
+	priv = devm_kzalloc(dev, sizeof(struct imx708), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	tc_dev = devm_kzalloc(dev, sizeof(struct tegracam_device), GFP_KERNEL);
+	if (!tc_dev)
+		return -ENOMEM;
+
+	priv->i2c_client = tc_dev->client = client;
+	tc_dev->dev = dev;
+	strncpy(tc_dev->name, "imx708", sizeof(tc_dev->name));
+	tc_dev->dev_regmap_config = &sensor_regmap_config;
+	tc_dev->sensor_ops = &imx708_common_ops;
+	tc_dev->v4l2sd_internal_ops = &imx708_subdev_internal_ops;
+	tc_dev->tcctrl_ops = &imx708_ctrl_ops;
+
+	err = tegracam_device_register(tc_dev);
+	if (err) {
+		dev_err(dev, "tegra camera driver registration failed\n");
+		goto register_error;
+	}
+	priv->tc_dev = tc_dev;
+	priv->s_data = tc_dev->s_data;
+	priv->subdev = &tc_dev->s_data->subdev;
+	tegracam_set_privdata(tc_dev, (void *)priv);
+
+	err = imx708_board_setup(priv);
+	if (err) {
+		dev_err(dev, "board setup failed\n");
+		goto tegracam_error;
+	}
+
+	err = tegracam_v4l2subdev_register(tc_dev, true);
+	if (err) {
+		dev_err(dev, "tegra camera subdev registration failed\n");
+		goto v4l2_error;
+	}
+
+	dev_dbg(dev, "detected imx708 sensor\n");
+
+	return 0;
+
+v4l2_error:
+	tegracam_v4l2subdev_unregister(priv->tc_dev);
+tegracam_error:
+	tegracam_device_unregister(priv->tc_dev);
+register_error:
+	return err;
+
+}
+
+
+static int imx708_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct imx708 *priv = (struct imx708 *)s_data->priv;
+	tegracam_v4l2subdev_unregister(priv->tc_dev);
+	tegracam_device_unregister(priv->tc_dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id imx708_id[] = {
+	{"imx708", 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, imx708_id);
+
+static struct i2c_driver imx708_i2c_driver = {
+	.driver = {
+		   .name = "imx708",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(imx708_of_match),
+		   },
+	.probe = imx708_probe,
+	.remove = imx708_remove,
+	.id_table = imx708_id,
+};
+
+module_i2c_driver(imx708_i2c_driver);
+
+MODULE_DESCRIPTION("Media Controller driver for Sony IMX708");
+MODULE_AUTHOR("RidgeRun");
+MODULE_LICENSE("GPL v2");
diff --git a/nvidia-oot/include/media/imx708.h b/nvidia-oot/include/media/imx708.h
new file mode 100644
index 000000000..1e98f4c1e
--- /dev/null
+++ b/nvidia-oot/include/media/imx708.h
@@ -0,0 +1,53 @@
+/*
+ * imx708.h - imx708 sensor header
+ *
+ * Copyright (c) 2023, RidgeRun <support@ridgerun.com>. All rights reserved.
+ *
+ * Contact us: support@ridgerun.com
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __IMX708_H__
+#define __IMX708_H__
+
+/* imx708 - sensor parameters */
+#define IMX708_MIN_GAIN		                (0)
+#define IMX708_MAX_GAIN		                (978)
+#define IMX708_ANALOG_GAIN_C0		        (516)
+#define IMX708_SHIFT_8_BITS			(8)
+#define IMX708_MIN_FRAME_LENGTH		        (256)
+#define IMX708_MAX_FRAME_LENGTH		        (65535)
+#define IMX708_MIN_COARSE_EXPOSURE	        (1)
+#define IMX708_MAX_COARSE_DIFF		        (10)
+#define IMX708_MASK_LSB_2_BITS			0x0003
+#define IMX708_MASK_LSB_8_BITS			0x00ff
+
+/* imx708 sensor register address */
+#define IMX708_MODEL_ID_ADDR_MSB		0x0000
+#define IMX708_MODEL_ID_ADDR_LSB		0x0001
+#define IMX708_MODEL_ID_VALUE_MSB		0x0003
+#define IMX708_MODEL_ID_VALUE_LSB		0x0001
+#define IMX708_ANALOG_GAIN_ADDR_MSB		0x0204
+#define IMX708_ANALOG_GAIN_ADDR_LSB		0x0205
+#define IMX708_DIGITAL_GAIN_ADDR_MSB		0x020e
+#define IMX708_DIGITAL_GAIN_ADDR_LSB		0x020f
+#define IMX708_FRAME_LENGTH_ADDR_MSB		0x0340
+#define IMX708_FRAME_LENGTH_ADDR_LSB		0x0341
+#define IMX708_COARSE_INTEG_TIME_ADDR_MSB	0x0202
+#define IMX708_COARSE_INTEG_TIME_ADDR_LSB	0x0203
+#define IMX708_FINE_INTEG_TIME_ADDR_MSB		0x0200
+#define IMX708_FINE_INTEG_TIME_ADDR_LSB		0x0201
+#define IMX708_GROUP_HOLD_ADDR		        0x0104
+
+#endif /* __IMX708_H__ */
-- 
2.34.1

