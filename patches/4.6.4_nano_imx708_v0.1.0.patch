From f9091eed7c28fe3c072ab72e4bdb892966d79a94 Mon Sep 17 00:00:00 2001
From: alfredpchacon <mac.pinnock@ridgerun.com>
Date: Tue, 25 Jul 2023 20:34:03 +0000
Subject: [PATCH] Squashed commit of the following:
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

commit 233ef2094eea38fe750e12ac1ec2561145c0471c
Merge: ccfdcc7fc f481e9579
Author: Mac Alfred Pinnock Chacón <mac.pinnock@ridgerun.com>
Date:   Tue Jul 25 20:30:39 2023 +0000

    Merge branch '4.6.4/nano/imx708-dev' into '4.6.4/nano/imx708'

    IMX708 for Jetson Nano 2 GB single camera platform

    See merge request ridgerun/drivers/jetson/nano-drivers!70

commit f481e9579025a4ff4d204d945d03fd534d9b8d84
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Tue Jul 25 20:05:07 2023 +0000

    Change compatible

commit 18b5f0d4bee716e8ee7a481c5ae188df93fd8b7b
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Tue Jul 25 19:30:54 2023 +0000

    Add SISO logic

commit 9f5a2f85be89c277ab26c84f4377cdb616405197
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Tue Jul 25 18:29:24 2023 +0000

    Fix driver error

commit 4358bcfbe4b3f5ea9fb1bf00c1e7191db18d7044
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Tue Jul 25 18:28:55 2023 +0000

    Remove extra code

commit c76da6346c0e457038bf36350c8ab5aabd824b0c
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Tue Jul 25 16:17:22 2023 +0000

    Remove unnecesary logic

commit 2075817a689bbca31c9516f649d7e752d61c722f
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Tue Jul 25 15:31:50 2023 +0000

    Add compatible

commit 77fce7f58f3771e155be187a193e3e3cee582aaa
Author: Mac Alfred Pinnock Chacón <mac.pinnock@ridgerun.com>
Date:   Mon Jul 24 03:58:47 2023 +0000

    Fix format

commit f1eeb2c2788000311125a103f0643f3d7147d450
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Mon Jul 24 03:03:55 2023 +0000

    Set IMX708 as default in menuconfig

commit 58796e2a18f26fa511e02aa41d9dc990850c77d7
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sat Jul 22 21:27:30 2023 +0000

    Add unregister driver

commit b4107fa9c2791da4ac604864f803492a4935ac3f
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sat Jul 22 21:02:42 2023 +0000

    Add define

commit e52182573ebfe46fa91b07a84e8dea489c461fc3
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sat Jul 22 20:57:06 2023 +0000

    Check max/min value from user

commit b873271f1f06a9399e8ae3e801014d70e08b1671
Author: Mac Alfred Pinnock Chacón <mac.pinnock@ridgerun.com>
Date:   Thu Jul 20 02:50:01 2023 +0000

    Remove duplicated empty line

commit eb06bf2adf242eddeed8862d9d565682a83c9578
Author: Mac Alfred Pinnock Chacón <mac.pinnock@ridgerun.com>
Date:   Thu Jul 20 02:48:45 2023 +0000

    Set duplicated empty line

commit a7a16a55456e1766ac9413c6aa1fe346cc3699ea
Author: Mac Alfred Pinnock Chacón <mac.pinnock@ridgerun.com>
Date:   Thu Jul 20 02:44:20 2023 +0000

    Remove trashy code

commit 6bbe1bdd118fb73d2b521ee2f4b49e3b2c5f07dc
Author: Mac Alfred Pinnock Chacón <mac.pinnock@ridgerun.com>
Date:   Thu Jul 20 02:08:48 2023 +0000

    Fix name error

commit dfd0915c9427728f6a6e2be7c2792b37c9d2c6f9
Author: Mac Alfred Pinnock Chacón <mac.pinnock@ridgerun.com>
Date:   Thu Jul 20 02:06:47 2023 +0000

    Remove extra dependency

commit e19a7a9b83e085de52d3436439fabf57918b9ae2
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Wed Jul 19 19:08:24 2023 +0000

    Remove extra dependencies

commit 124eaec279b94c143b47e73c9d6a4668be78b90c
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Wed Jul 19 19:05:49 2023 +0000

    Initialize variables

commit 154a7721510b3603d2ffc0ed27e199974d7ff3d3
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Wed Jul 19 19:05:30 2023 +0000

    Remove extra file

commit 81570e32c649f7774dba6dc8aa4d82033aed109f
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Wed Jul 19 19:01:31 2023 +0000

    Remove debug errors

commit ca04f48008779672235163ab02e3a827ebfdb249
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Mon Jul 17 20:45:26 2023 +0000

    Remove extra copyright

commit 263376c288b84526b828fce18846f7c63ece213d
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Mon Jul 17 20:43:25 2023 +0000

    Remove extra file

commit 87c61156be6340ef8c17e9a1df411ac7a5f8903b
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Mon Jul 17 17:01:16 2023 +0000

    Remove commented code

commit 56aac8f017cb11fd9ee261efb232542108c2d76c
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Mon Jul 17 16:59:02 2023 +0000

    Renove extra dependencies

commit 0f71188d82dbbd82ec1ac86a2cc0be4fab816666
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Mon Jul 17 16:58:34 2023 +0000

    Change dtb ordering

commit 481520e5e2cc5f0e1de27b69c9e14fa9eaaac293
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Mon Jul 17 16:25:35 2023 +0000

    Remove extra files

commit 141561c8a3234097c46e5d2aeeca2f047154ee51
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Mon Jul 17 16:11:16 2023 +0000

    remove commented code

commit c40b8fa4dfeadb4da35249635364c440efd56037
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Mon Jul 17 15:44:08 2023 +0000

    Fix the capture image error

commit 3899f631cdde9431058058aeb2d6cf4193aa3d95
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sun Jul 9 19:13:19 2023 +0000

    Add dependencies to overrides makefile

commit 73fff9ecaa9fd6c959f3930079ba674e6635e43f
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sun Jul 9 19:12:28 2023 +0000

    Fix indentation error

commit c715e20c6789ba969bf982c07b90188e7d2da203
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sun Jul 9 19:12:14 2023 +0000

    Increase verbosity

commit 6284e827fc67e2bf13bedd413c8b284ef5913df4
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sun Jul 9 19:12:01 2023 +0000

    Disable unnecsary logic

commit 71ff1d47224ce62434f38060e3c7674943cf5e1f
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sun Jul 9 19:11:46 2023 +0000

    Fix name error

commit a4dde960e4ed58def5b0820358a50d8ca567e099
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Sun Jul 9 19:11:19 2023 +0000

    Add overrides

commit 67d23be862945c7acc5556535a8b413537523545
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Thu Jul 6 04:03:55 2023 +0000

    Add missing dependencie

commit 32a95c92de45d2481b64b59acc2b975a4043acd8
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Thu Jul 6 04:03:29 2023 +0000

    Add dependencie for nano 2gb

commit d669df6d16b8ec7359b74d79f02c24dd0562daea
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Wed Jul 5 19:10:20 2023 +0000

    Add sensor header

commit 517d3e14b825d0dfa2fd6a6cd1741f8495b9de3f
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Wed Jul 5 19:09:55 2023 +0000

    Add driver to compililation dependencies

commit 8cd996967665856e51512071f24c484d36c26c01
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Wed Jul 5 18:58:25 2023 +0000

    Add .c file

commit b5059198c5bdb7e9e15844dc53cbd0677ef35c25
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Wed Jul 5 18:57:52 2023 +0000

    Add header file

commit ca8a355633184c2bf77bd71158e09022f6ef76d6
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Wed Jul 5 18:56:40 2023 +0000

    Revert "Add .c and .h driver files"

    This reverts commit 632597d8eabdb849fca876713c80034c62b74ece.

commit 632597d8eabdb849fca876713c80034c62b74ece
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Wed Jul 5 18:55:00 2023 +0000

    Add .c and .h driver files

commit f10841dba3034737f7f4ed1c3bdfe6075438b784
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Wed Jul 5 18:53:18 2023 +0000

    Include files in the hierarchy

commit d1e2b9a4af0b2a5120ee4cfb98c2125c0197c859
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Wed Jul 5 18:49:48 2023 +0000

    Add dtsi for single camera platforms

commit 8811c6e12be2a4c0754b58930eb49dba999feb4e
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Wed Jul 5 18:23:18 2023 +0000

    Add kconfig description

commit 71ab919ab5a72aaa49beba47a238ac0d2cec949e
Author: alfredpchacon <mac.pinnock@ridgerun.com>
Date:   Wed Jul 5 18:23:04 2023 +0000

    Add dtsi files
---
 .../tegra210-p3448-0003-p3542-0000.dts        |   1 +
 .../tegra210-camera-rbpcv3-imx708.dtsi        | 166 ++++
 .../tegra210-porg-camera-rbpcv3-imx708.dtsi   |  41 +
 kernel/nvidia/drivers/media/i2c/Kconfig       |   9 +
 kernel/nvidia/drivers/media/i2c/Makefile      |   1 +
 kernel/nvidia/drivers/media/i2c/imx708.c      | 774 ++++++++++++++++++
 .../drivers/media/i2c/imx708_mode_tbls.h      | 221 +++++
 kernel/nvidia/include/media/imx708.h          |  51 ++
 9 files changed, 1271 insertions(+), 6 deletions(-)
 create mode 100644 hardware/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv3-imx708.dtsi
 create mode 100644 hardware/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv3-imx708.dtsi
 create mode 100644 kernel/nvidia/drivers/media/i2c/imx708.c
 create mode 100644 kernel/nvidia/drivers/media/i2c/imx708_mode_tbls.h
 create mode 100644 kernel/nvidia/include/media/imx708.h

diff --git a/hardware/nvidia/platform/t210/batuu/kernel-dts/tegra210-p3448-0003-p3542-0000.dts b/hardware/nvidia/platform/t210/batuu/kernel-dts/tegra210-p3448-0003-p3542-0000.dts
index 7d19df5a8..0a2c678d5 100644
--- a/hardware/nvidia/platform/t210/batuu/kernel-dts/tegra210-p3448-0003-p3542-0000.dts
+++ b/hardware/nvidia/platform/t210/batuu/kernel-dts/tegra210-p3448-0003-p3542-0000.dts
@@ -21,6 +21,7 @@
 #include "../../porg/kernel-dts/tegra210-porg-p3448-common.dtsi"
 #include "../../porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv3-imx477.dtsi"
 #include "../../porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-imx219.dtsi"
+#include "../../porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv3-imx708.dtsi"
 #include "batuu-platforms/tegra210-batuu-pinmux-p3448-0003.dtsi"
 #include "batuu-platforms/tegra210-batuu-gpio-p3448-0003.dtsi"
 #include "batuu-platforms/tegra210-batuu-p3448-emc-a00.dtsi"
diff --git a/hardware/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv3-imx708.dtsi b/hardware/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv3-imx708.dtsi
new file mode 100644
index 000000000..00b5473c5
--- /dev/null
+++ b/hardware/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv3-imx708.dtsi
@@ -0,0 +1,166 @@
+/*
+ * Copyright (c) 2021, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2023, RidgeRun <support@ridgerun.com>. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <dt-bindings/media/camera.h>
+#include <dt-bindings/platform/t210/t210.h>
+
+/ {
+	host1x {
+		vi_base: vi {
+			num-channels = <1>;
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				vi_port0: port@0 {
+					reg = <0>;
+					rbpcv3_imx708_vi_in0: endpoint {
+						status="okay";
+						port-index = <0>;
+						bus-width = <2>;
+						remote-endpoint = <&rbpcv3_imx708_csi_out0>;
+					};
+				};
+			};
+		};
+
+		csi_base: nvcsi {
+			num-channels = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			csi_chan0: channel@0 {
+				reg = <0>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					csi_chan0_port0: port@0 {
+						reg = <0>;
+						rbpcv3_imx708_csi_in0: endpoint@0 {
+							status="okay";
+							port-index = <0>;
+							bus-width = <2>;
+							remote-endpoint = <&rbpcv3_imx708_out0>;
+						};
+					};
+					csi_chan0_port1: port@1 {
+						reg = <1>;
+						rbpcv3_imx708_csi_out0: endpoint@1 {
+							status = "okay";
+							remote-endpoint = <&rbpcv3_imx708_vi_in0>;
+						};
+					};
+				};
+			};
+		};
+
+		i2c@546c0000 {
+			imx708_single_cam0: rbpcv3_imx708_a@1a {
+				status = "okay";
+				compatible = "sony,imx708";
+				reg = <0x1a>;
+				devnode = "video0";
+				physical_w = "3.680";
+				physical_h = "2.760";
+				sensor_model = "imx708";
+				use_sensor_mode_id = "true";
+
+				/* IMX708_MODE_4608x2592_14fps */
+				mode0 {
+					mclk_khz = "24000";
+					num_lanes = "2";
+					tegra_sinterface = "serial_a";
+					phy_mode = "DPHY";
+					discontinuous_clk = "yes";
+					dpcm_enable = "false";
+					cil_settletime = "0";
+
+					active_w = "4608";
+					active_h = "2592";
+					mode_type = "bayer";
+					pixel_phase = "rggb";
+					csi_pixel_bit_depth = "10";
+					readout_orientation = "90";
+					line_length = "15648";
+					inherent_gain = "1";
+					pix_clk_hz = "595200000"; 
+
+					gain_factor = "16";
+					framerate_factor = "1000000";
+					exposure_factor = "1000000";
+					min_gain_val = "16"; 
+					max_gain_val = "512"; 
+					step_gain_val = "1";
+					default_gain = "16";
+					min_hdr_ratio = "1";
+					max_hdr_ratio = "1";
+					min_framerate = "2000000";
+					max_framerate = "14000000";
+					step_framerate = "1";
+					default_framerate = "14000000";
+					min_exp_time = "500";
+					max_exp_time = "65487";
+					step_exp_time = "1";
+					default_exp_time = "1600";
+					embedded_metadata_height = "2";
+				};
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					port@0 {
+						reg = <0>;
+						rbpcv3_imx708_out0: endpoint {
+							port-index = <0>;
+							bus-width = <2>;
+							remote-endpoint = <&rbpcv3_imx708_csi_in0>;
+						};
+					};
+				};
+			};
+		};
+	};
+};
+
+/ {
+	tcp: tegra-camera-platform {
+		compatible = "nvidia, tegra-camera-platform";
+		num_csi_lanes = <2>;
+		max_lane_speed = <2500000>;
+		min_bits_per_pixel = <10>;
+		vi_peak_byte_per_pixel = <2>;
+		vi_bw_margin_pct = <25>;
+		max_pixel_rate = <7500000>;
+		isp_peak_byte_per_pixel = <5>;
+		isp_bw_margin_pct = <25>;
+
+		modules {
+			cam_module0: module0 {
+				status = "okay";
+				badge = "porg_front_RBPCV3";
+				position = "front";
+				orientation = "1";
+				cam_module0_drivernode0: drivernode0 {
+					status = "okay";
+					pcl_id = "v4l2_sensor";
+					devname = "imx708 6-001a";
+					proc-device-tree = "/proc/device-tree/host1x/i2c@546c0000/rbpcv3_imx708_a@1a";
+				};
+			};
+		};
+	};
+};
diff --git a/hardware/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv3-imx708.dtsi b/hardware/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv3-imx708.dtsi
new file mode 100644
index 000000000..581ebe406
--- /dev/null
+++ b/hardware/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv3-imx708.dtsi
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2021, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2023, RidgeRun.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "tegra210-camera-rbpcv3-imx708.dtsi"
+
+#define CAM1_PWDN		TEGRA_GPIO(S, 7)
+
+/ {
+	host1x {
+		i2c@546c0000 {
+			rbpcv3_imx708_a@1a {
+				status = "okay";
+				reset-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
+			};
+		};
+	};
+
+	gpio@6000d000 {
+		camera-control-output-low {
+			gpio-hog;
+			output-low;
+			gpios = < CAM1_PWDN 0 >;
+			label = "cam1-pwdn";
+		};
+	};
+};
diff --git a/kernel/nvidia/drivers/media/i2c/Kconfig b/kernel/nvidia/drivers/media/i2c/Kconfig
index 326dbb096..99398a22c 100644
--- a/kernel/nvidia/drivers/media/i2c/Kconfig
+++ b/kernel/nvidia/drivers/media/i2c/Kconfig
@@ -13,6 +13,15 @@ config VIDEO_IMX185
 	To compile this driver as a module, choose M here: the module
 	will be called imx185.
 
+config VIDEO_IMX708
+        tristate "IMX708 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	---help---
+	  This driver supports IMX708 camera sensor from Sony
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called imx708.
+
 config VIDEO_IMX477
         tristate "IMX477 camera sensor support"
 	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
diff --git a/kernel/nvidia/drivers/media/i2c/Makefile b/kernel/nvidia/drivers/media/i2c/Makefile
index c6d34e807..3d0947d4f 100644
--- a/kernel/nvidia/drivers/media/i2c/Makefile
+++ b/kernel/nvidia/drivers/media/i2c/Makefile
@@ -5,6 +5,7 @@ ccflags-y += -I$(srctree)/drivers/video/tegra/camera
 
 obj-$(CONFIG_VIDEO_IMX185) += imx185.o
 obj-$(CONFIG_VIDEO_IMX185) += imx185_v1.o
+obj-$(CONFIG_VIDEO_IMX708) += imx708.o
 obj-$(CONFIG_VIDEO_IMX477) += imx477.o
 obj-$(CONFIG_VIDEO_IMX219) += imx219.o
 obj-$(CONFIG_VIDEO_IMX268) += imx268.o
diff --git a/kernel/nvidia/drivers/media/i2c/imx708.c b/kernel/nvidia/drivers/media/i2c/imx708.c
new file mode 100644
index 000000000..c33fc24b5
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/imx708.c
@@ -0,0 +1,774 @@
+/*
+ * imx708.c - imx708 sensor driver
+ *
+ * Copyright (c) 2021-2023, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2023, RidgeRun <support@ridgerun.com>. All rights reserved.
+ *
+ * Contact us: support@ridgerun.com
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <media/tegra_v4l2_camera.h>
+#include <media/tegracam_core.h>
+#include <media/imx708.h>
+
+#include "../platform/tegra/camera/camera_gpio.h"
+#include "imx708_mode_tbls.h"
+
+static const struct of_device_id imx708_of_match[] = {
+	{.compatible = "sony,imx708",},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, imx708_of_match);
+
+static const u32 ctrl_cid_list[] = {
+	TEGRA_CAMERA_CID_GAIN,
+	TEGRA_CAMERA_CID_EXPOSURE,
+	TEGRA_CAMERA_CID_FRAME_RATE,
+	TEGRA_CAMERA_CID_SENSOR_MODE_ID,
+};
+
+struct imx708 {
+	struct i2c_client *i2c_client;
+	struct v4l2_subdev *subdev;
+	u16 fine_integ_time;
+	u32 frame_length;
+	struct camera_common_data *s_data;
+	struct tegracam_device *tc_dev;
+};
+
+static const struct regmap_config sensor_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+#if KERNEL_VERSION(5, 4, 0) > LINUX_VERSION_CODE
+		.use_single_rw = true,
+#else
+		.use_single_read = true,
+		.use_single_write = true,
+#endif
+};
+
+static inline void imx708_get_frame_length_regs(imx708_reg * regs,
+						u32 frame_length)
+{
+	regs->addr = IMX708_FRAME_LENGTH_ADDR_MSB;
+	regs->val = (frame_length >> 8) & 0xff;
+	(regs + 1)->addr = IMX708_FRAME_LENGTH_ADDR_LSB;
+	(regs + 1)->val = (frame_length) & 0xff;
+}
+
+static inline void imx708_get_coarse_integ_time_regs(imx708_reg * regs,
+						     u32 coarse_time)
+{
+	regs->addr = IMX708_COARSE_INTEG_TIME_ADDR_MSB;
+	regs->val = (coarse_time >> 8) & 0xff;
+	(regs + 1)->addr = IMX708_COARSE_INTEG_TIME_ADDR_LSB;
+	(regs + 1)->val = (coarse_time) & 0xff;
+}
+
+static inline void imx708_get_gain_reg(imx708_reg * reg, u16 gain)
+{
+	reg->addr = IMX708_ANALOG_GAIN_ADDR_MSB;
+	reg->val = (gain >> IMX708_SHIFT_8_BITS) & IMX708_MASK_LSB_2_BITS;
+
+	(reg + 1)->addr = IMX708_ANALOG_GAIN_ADDR_LSB;
+	(reg + 1)->val = (gain) & IMX708_MASK_LSB_8_BITS;
+}
+
+static inline int imx708_read_reg(struct camera_common_data *s_data,
+				  u16 addr, u8 * val)
+{
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(s_data->regmap, addr, &reg_val);
+	*val = reg_val & 0xff;
+
+	return err;
+}
+
+static inline int imx708_write_reg(struct camera_common_data *s_data,
+				   u16 addr, u8 val)
+{
+	int err = 0;
+
+	err = regmap_write(s_data->regmap, addr, val);
+	if (err)
+		dev_err(s_data->dev, "%s: i2c write failed, 0x%x = %x",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int imx708_write_table(struct imx708 *priv, const imx708_reg table[])
+{
+	return regmap_util_write_table_8(priv->s_data->regmap, table, NULL, 0,
+					 IMX708_TABLE_WAIT_MS,
+					 IMX708_TABLE_END);
+}
+
+static int imx708_set_group_hold(struct tegracam_device *tc_dev, bool val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct device *dev = tc_dev->dev;
+	int err = 0;
+
+	dev_dbg(dev, "%s: Setting group hold control to: %u\n", __func__, val);
+
+	err = imx708_write_reg(s_data, IMX708_GROUP_HOLD_ADDR, val);
+	if (err) {
+		dev_err(dev, "%s: Group hold control error\n", __func__);
+		return err;
+	}
+
+	return 0;
+}
+
+static int imx708_get_fine_integ_time(struct imx708 *priv, u16 * fine_time)
+{
+	struct camera_common_data *s_data = priv->s_data;
+	int err = 0;
+	u8 reg_val[2] = {0};
+
+	err = imx708_read_reg(s_data, IMX708_FINE_INTEG_TIME_ADDR_MSB,
+			      &reg_val[0]);
+	if (err)
+		goto done;
+
+	err = imx708_read_reg(s_data, IMX708_FINE_INTEG_TIME_ADDR_LSB,
+			      &reg_val[1]);
+	if (err)
+		goto done;
+
+	*fine_time = (reg_val[0] << 8) | reg_val[1];
+
+done:
+	return err;
+}
+
+static int imx708_set_gain(struct tegracam_device *tc_dev, s64 val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct device *dev = s_data->dev;
+	const struct sensor_mode_properties *mode =
+	    &s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+	int err = 0; 
+	int i = 0;
+	imx708_reg gain_reg[2] = {0};
+	s16 gain = 0;
+
+	dev_dbg(dev, "%s: Setting gain control to: %lld\n", __func__, val);
+
+	/* Gain Formula:
+	   Gain = (IMX708_GAIN_C0 - (IMX708_GAIN_C0 * gain_factor / val))
+	 */
+	gain =
+	    (s16) (IMX708_ANALOG_GAIN_C0 -
+		   (mode->control_properties.gain_factor *
+		    IMX708_ANALOG_GAIN_C0 / val));
+
+	dev_dbg(dev, "%s: val: %lld (/%d) [times], gain: %u\n",
+		__func__, val, mode->control_properties.gain_factor, gain);
+
+	imx708_get_gain_reg(gain_reg, (u16) gain);
+
+	for (i = 0; i < ARRAY_SIZE(gain_reg); i++) {
+		err = imx708_write_reg(s_data, gain_reg[i].addr,
+				       gain_reg[i].val);
+		if (err) {
+			dev_err(dev, "%s: gain control error\n", __func__);
+			break;
+		}
+	}
+
+	return err;
+}
+
+static int imx708_set_frame_rate(struct tegracam_device *tc_dev, s64 val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct imx708 *priv = (struct imx708 *)tc_dev->priv;
+	struct device *dev = tc_dev->dev;
+	const struct sensor_mode_properties *mode =
+	    &s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+
+	int err = 0;
+	imx708_reg fl_regs[2] = {0};
+	u32 frame_length = 0;
+	int i = 0;
+
+	dev_dbg(dev, "%s: Setting framerate control to: %lld\n", __func__, val);
+
+	frame_length = (u32)(mode->signal_properties.pixel_clock.val *
+		(u64)mode->control_properties.framerate_factor /
+		mode->image_properties.line_length / val);
+
+	dev_dbg(dev,
+		"%s: val: %llde-6 [fps], frame_length: %u [lines]\n",
+		__func__, val, frame_length);
+
+	imx708_get_frame_length_regs(fl_regs, frame_length);
+	for (i = 0; i < 2; i++) {
+		err = imx708_write_reg(s_data, fl_regs[i].addr, fl_regs[i].val);
+		if (err) {
+			dev_err(dev,
+				"%s: frame_length control error\n", __func__);
+			return err;
+		}
+	}
+
+	priv->frame_length = frame_length;
+
+	return err;
+}
+
+static int imx708_set_exposure(struct tegracam_device *tc_dev, s64 val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct imx708 *priv = (struct imx708 *)tc_dev->priv;
+	struct device *dev = tc_dev->dev;
+	const struct sensor_mode_properties *mode =
+	    &s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+
+	int err = 0;
+	imx708_reg ct_regs[2] = {0};
+	const s32 fine_integ_time_factor = priv->fine_integ_time *
+	    mode->control_properties.exposure_factor /
+	    mode->signal_properties.pixel_clock.val;
+	u32 coarse_time = 0;
+	int i = 0;
+
+	dev_dbg(dev, "%s: Setting exposure control to: %lld\n", __func__, val);
+
+	coarse_time = (val - fine_integ_time_factor)
+	    * mode->signal_properties.pixel_clock.val
+	    / mode->control_properties.exposure_factor
+	    / mode->image_properties.line_length;
+
+	dev_dbg(dev, "%s: val: %lld [us], coarse_time: %d [lines]\n",
+		__func__, val, coarse_time);
+
+	imx708_get_coarse_integ_time_regs(ct_regs, coarse_time);
+
+	for (i = 0; i < 2; i++) {
+		err = imx708_write_reg(s_data, ct_regs[i].addr, ct_regs[i].val);
+		if (err) {
+			dev_err(dev,
+				"%s: coarse_time control error\n", __func__);
+			return err;
+		}
+	}
+
+	return err;
+}
+
+static struct tegracam_ctrl_ops imx708_ctrl_ops = {
+	.numctrls = ARRAY_SIZE(ctrl_cid_list),
+	.ctrl_cid_list = ctrl_cid_list,
+	.set_gain = imx708_set_gain,
+	.set_exposure = imx708_set_exposure,
+	.set_frame_rate = imx708_set_frame_rate,
+	.set_group_hold = imx708_set_group_hold,
+};
+
+static int imx708_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+
+	dev_dbg(dev, "%s: power on\n", __func__);
+	if (pdata && pdata->power_on) {
+		err = pdata->power_on(pw);
+		if (err)
+			dev_err(dev, "%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+
+	if (pw->reset_gpio) {
+		if (gpio_cansleep(pw->reset_gpio))
+			gpio_set_value_cansleep(pw->reset_gpio, 0);
+		else
+			gpio_set_value(pw->reset_gpio, 0);
+	}
+
+	if (unlikely(!(pw->avdd || pw->iovdd || pw->dvdd)))
+		goto skip_power_seqn;
+
+	usleep_range(10, 20);
+
+	if (pw->avdd) {
+		err = regulator_enable(pw->avdd);
+		if (err)
+			goto imx708_avdd_fail;
+	}
+
+	if (pw->iovdd) {
+		err = regulator_enable(pw->iovdd);
+		if (err)
+			goto imx708_iovdd_fail;
+	}
+
+	if (pw->dvdd) {
+		err = regulator_enable(pw->dvdd);
+		if (err)
+			goto imx708_dvdd_fail;
+	}
+
+	usleep_range(10, 20);
+
+skip_power_seqn:
+	if (pw->reset_gpio) {
+		if (gpio_cansleep(pw->reset_gpio))
+			gpio_set_value_cansleep(pw->reset_gpio, 1);
+		else
+			gpio_set_value(pw->reset_gpio, 1);
+	}
+
+	/* Need to wait for t4 + t5 + t9 + t10 time as per the data sheet */
+	/* t4 - 200us, t5 - 21.2ms, t9 - 1.2ms t10 - 270 ms */
+	usleep_range(300000, 300100);
+
+	pw->state = SWITCH_ON;
+
+	return 0;
+
+imx708_dvdd_fail:
+	regulator_disable(pw->iovdd);
+
+imx708_iovdd_fail:
+	regulator_disable(pw->avdd);
+
+imx708_avdd_fail:
+	dev_err(dev, "%s failed.\n", __func__);
+
+	return -ENODEV;
+}
+
+static int imx708_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+
+	dev_dbg(dev, "%s: power off\n", __func__);
+
+	if (pdata && pdata->power_off) {
+		err = pdata->power_off(pw);
+		if (err) {
+			dev_err(dev, "%s failed.\n", __func__);
+			return err;
+		}
+	} else {
+		if (pw->reset_gpio) {
+			if (gpio_cansleep(pw->reset_gpio))
+				gpio_set_value_cansleep(pw->reset_gpio, 0);
+			else
+				gpio_set_value(pw->reset_gpio, 0);
+		}
+
+		usleep_range(10, 10);
+
+		if (pw->dvdd)
+			regulator_disable(pw->dvdd);
+		if (pw->iovdd)
+			regulator_disable(pw->iovdd);
+		if (pw->avdd)
+			regulator_disable(pw->avdd);
+	}
+
+	pw->state = SWITCH_OFF;
+
+	return 0;
+}
+
+static int imx708_power_put(struct tegracam_device *tc_dev)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+
+	if (unlikely(!pw))
+		return -EFAULT;
+
+	if (likely(pw->dvdd))
+		devm_regulator_put(pw->dvdd);
+
+	if (likely(pw->avdd))
+		devm_regulator_put(pw->avdd);
+
+	if (likely(pw->iovdd))
+		devm_regulator_put(pw->iovdd);
+
+	pw->dvdd = NULL;
+	pw->avdd = NULL;
+	pw->iovdd = NULL;
+
+	if (likely(pw->reset_gpio))
+		gpio_free(pw->reset_gpio);
+
+	return 0;
+}
+
+static int imx708_power_get(struct tegracam_device *tc_dev)
+{
+	struct device *dev = tc_dev->dev;
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct clk *parent;
+	int err = 0;
+
+	if (!pdata) {
+		dev_err(dev, "pdata missing\n");
+		return -EFAULT;
+	}
+
+	/* Sensor MCLK (aka. INCK) */
+	if (pdata->mclk_name) {
+		pw->mclk = devm_clk_get(dev, pdata->mclk_name);
+		if (IS_ERR(pw->mclk)) {
+			dev_err(dev, "unable to get clock %s\n",
+				pdata->mclk_name);
+			return PTR_ERR(pw->mclk);
+		}
+
+		if (pdata->parentclk_name) {
+			parent = devm_clk_get(dev, pdata->parentclk_name);
+			if (IS_ERR(parent)) {
+				dev_err(dev, "unable to get parent clock %s",
+					pdata->parentclk_name);
+			} else
+				clk_set_parent(pw->mclk, parent);
+		}
+	}
+
+	/* analog 2.8v */
+	if (pdata->regulators.avdd)
+		err |= camera_common_regulator_get(dev,
+						   &pw->avdd,
+						   pdata->regulators.avdd);
+	/* IO 1.8v */
+	if (pdata->regulators.iovdd)
+		err |= camera_common_regulator_get(dev,
+						   &pw->iovdd,
+						   pdata->regulators.iovdd);
+	/* dig 1.2v */
+	if (pdata->regulators.dvdd)
+		err |= camera_common_regulator_get(dev,
+						   &pw->dvdd,
+						   pdata->regulators.dvdd);
+	if (err) {
+		dev_err(dev, "%s: unable to get regulator(s)\n", __func__);
+		goto done;
+	}
+
+	/* Reset or ENABLE GPIO */
+	pw->reset_gpio = pdata->reset_gpio;
+	err = gpio_request(pw->reset_gpio, "cam_reset_gpio");
+	if (err < 0) {
+		dev_err(dev, "%s: unable to request reset_gpio (%d)\n",
+			__func__, err);
+		goto done;
+	}
+
+done:
+	pw->state = SWITCH_OFF;
+
+	return err;
+}
+
+static struct camera_common_pdata *imx708_parse_dt(struct tegracam_device
+						   *tc_dev)
+{
+	struct device *dev = tc_dev->dev;
+	struct device_node *np = dev->of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	struct camera_common_pdata *ret = NULL;
+	int err = 0;
+	int gpio = 0;
+
+	if (!np)
+		return NULL;
+
+	match = of_match_device(imx708_of_match, dev);
+	if (!match) {
+		dev_err(dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	board_priv_pdata = devm_kzalloc(dev,
+					sizeof(*board_priv_pdata), GFP_KERNEL);
+	if (!board_priv_pdata)
+		return NULL;
+
+	gpio = of_get_named_gpio(np, "reset-gpios", 0);
+	if (gpio < 0) {
+		if (gpio == -EPROBE_DEFER)
+			ret = ERR_PTR(-EPROBE_DEFER);
+		dev_err(dev, "reset-gpios not found\n");
+		goto error;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+
+	err = of_property_read_string(np, "avdd-reg",
+				      &board_priv_pdata->regulators.avdd);
+	err |= of_property_read_string(np, "iovdd-reg",
+				       &board_priv_pdata->regulators.iovdd);
+	err |= of_property_read_string(np, "dvdd-reg",
+				       &board_priv_pdata->regulators.dvdd);
+	if (err)
+		dev_dbg(dev, "avdd, iovdd and/or dvdd reglrs. not present, "
+			"assume sensor powered independently\n");
+
+	board_priv_pdata->has_eeprom = of_property_read_bool(np, "has-eeprom");
+
+	return board_priv_pdata;
+
+error:
+	devm_kfree(dev, board_priv_pdata);
+
+	return ret;
+}
+
+static int imx708_set_mode(struct tegracam_device *tc_dev)
+{
+	struct imx708 *priv = (struct imx708 *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = tc_dev->s_data;
+
+	int err = 0;
+
+	err = imx708_write_table(priv, mode_table[IMX708_MODE_COMMON]);
+	if (err)
+	{
+		dev_err(tc_dev->dev, "failed writing common mode err:%d\n", err);
+		return err;
+	}
+
+	if (s_data->mode < 0)
+		return -EINVAL;
+	err = imx708_write_table(priv, mode_table[s_data->mode]);
+	if (err)
+	{
+		dev_err(tc_dev->dev, "failed to write mode %d  err:%d\n", s_data->mode, err);
+		return err;
+	}
+	
+	return 0;
+}
+
+
+static int imx708_start_streaming(struct tegracam_device *tc_dev)
+{
+	struct imx708 *priv = (struct imx708 *)tegracam_get_privdata(tc_dev);
+
+	dev_dbg(tc_dev->dev, "%s:\n", __func__);
+
+	return imx708_write_table(priv, mode_table[IMX708_START_STREAM]);
+}
+
+static int imx708_stop_streaming(struct tegracam_device *tc_dev)
+{
+	int err = 0;
+
+	struct imx708 *priv = (struct imx708 *)tegracam_get_privdata(tc_dev);
+
+	dev_dbg(tc_dev->dev, "%s:\n", __func__);
+
+	err = imx708_write_table(priv, mode_table[IMX708_STOP_STREAM]);
+
+	return err;
+}
+
+static struct camera_common_sensor_ops imx708_common_ops = {
+	.numfrmfmts = ARRAY_SIZE(imx708_frmfmt),
+	.frmfmt_table = imx708_frmfmt,
+	.power_on = imx708_power_on,
+	.power_off = imx708_power_off,
+	.write_reg = imx708_write_reg,
+	.read_reg = imx708_read_reg,
+	.parse_dt = imx708_parse_dt,
+	.power_get = imx708_power_get,
+	.power_put = imx708_power_put,
+	.set_mode = imx708_set_mode,
+	.start_streaming = imx708_start_streaming,
+	.stop_streaming = imx708_stop_streaming,
+};
+
+static int imx708_board_setup(struct imx708 *priv)
+{
+	struct camera_common_data *s_data = priv->s_data;
+	struct device *dev = s_data->dev;
+	u8 reg_val[2] = {0};
+	int err = 0;
+
+	/* Skip mclk enable as this camera has an internal oscillator */
+	err = imx708_power_on(s_data);
+	if (err) {
+		dev_err(dev, "error during power on sensor (%d)\n", err);
+		goto done;
+	}
+
+	/* Probe sensor model id registers */
+	err = imx708_read_reg(s_data, IMX708_MODEL_ID_ADDR_MSB, &reg_val[0]);
+	if (err) {
+		dev_err(dev, "%s: error during i2c read probe (%d)\n",
+			__func__, err);
+		goto err_reg_probe;
+	}
+	err = imx708_read_reg(s_data, IMX708_MODEL_ID_ADDR_LSB, &reg_val[1]);
+	if (err) {
+		dev_err(dev, "%s: error during i2c read probe (%d)\n",
+			__func__, err);
+		goto err_reg_probe;
+	}
+
+	if (!((reg_val[0] == IMX708_MODEL_ID_VALUE_MSB) &&
+		   reg_val[1] == IMX708_MODEL_ID_VALUE_LSB))
+		dev_err(dev, "%s: invalid sensor model id: %x%x\n",
+			__func__, reg_val[0], reg_val[1]);
+
+	/* Sensor fine integration time */
+	err = imx708_get_fine_integ_time(priv, &priv->fine_integ_time);
+	if (err)
+		dev_err(dev, "%s: error querying sensor fine integ. time\n",
+			__func__);
+
+err_reg_probe:
+	imx708_power_off(s_data);
+
+done:
+	return err;
+}
+
+static int imx708_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops imx708_subdev_internal_ops = {
+	.open = imx708_open,
+};
+
+static int imx708_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct tegracam_device *tc_dev = NULL;
+	struct imx708 *priv = NULL;
+	int err = 0; 
+
+	dev_dbg(dev, "probing v4l2 sensor at addr 0x%0x\n", client->addr);
+
+	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
+		return -EINVAL;
+
+	priv = devm_kzalloc(dev, sizeof(struct imx708), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	tc_dev = devm_kzalloc(dev, sizeof(struct tegracam_device), GFP_KERNEL);
+	if (!tc_dev)
+		return -ENOMEM;
+
+	priv->i2c_client = tc_dev->client = client;
+	tc_dev->dev = dev;
+	strncpy(tc_dev->name, "imx708", sizeof(tc_dev->name));
+	tc_dev->dev_regmap_config = &sensor_regmap_config;
+	tc_dev->sensor_ops = &imx708_common_ops;
+	tc_dev->v4l2sd_internal_ops = &imx708_subdev_internal_ops;
+	tc_dev->tcctrl_ops = &imx708_ctrl_ops;
+
+	err = tegracam_device_register(tc_dev);
+	if (err) {
+		dev_err(dev, "tegra camera driver registration failed\n");
+		goto register_error;
+	}
+	priv->tc_dev = tc_dev;
+	priv->s_data = tc_dev->s_data;
+	priv->subdev = &tc_dev->s_data->subdev;
+	tegracam_set_privdata(tc_dev, (void *)priv);
+
+	err = imx708_board_setup(priv);
+	if (err) {
+		dev_err(dev, "board setup failed\n");
+		goto tegracam_error;
+	}
+
+	err = tegracam_v4l2subdev_register(tc_dev, true);
+	if (err) {
+		dev_err(dev, "tegra camera subdev registration failed\n");
+		goto v4l2_error;
+	}
+
+	dev_dbg(dev, "detected imx708 sensor\n");
+
+	return 0;
+
+v4l2_error:
+	tegracam_v4l2subdev_unregister(priv->tc_dev);
+tegracam_error:
+	tegracam_device_unregister(priv->tc_dev);
+register_error:
+	return err;
+
+}
+
+
+static int imx708_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct imx708 *priv = (struct imx708 *)s_data->priv;
+
+	tegracam_v4l2subdev_unregister(priv->tc_dev);
+	tegracam_device_unregister(priv->tc_dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id imx708_id[] = {
+	{"imx708", 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, imx708_id);
+
+static struct i2c_driver imx708_i2c_driver = {
+	.driver = {
+		   .name = "imx708",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(imx708_of_match),
+		   },
+	.probe = imx708_probe,
+	.remove = imx708_remove,
+	.id_table = imx708_id,
+};
+
+module_i2c_driver(imx708_i2c_driver);
+
+MODULE_DESCRIPTION("Media Controller driver for Sony IMX708");
+MODULE_AUTHOR("RidgeRun");
+MODULE_LICENSE("GPL v2");
diff --git a/kernel/nvidia/drivers/media/i2c/imx708_mode_tbls.h b/kernel/nvidia/drivers/media/i2c/imx708_mode_tbls.h
new file mode 100644
index 000000000..ac7862b2d
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/imx708_mode_tbls.h
@@ -0,0 +1,221 @@
+/*
+ * Copyright (c) 2020-2023, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2023, RidgeRun <support@ridgerun.com>. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __IMX708_I2C_TABLES__
+#define __IMX708_I2C_TABLES__
+
+#include <media/camera_common.h>
+
+#define IMX708_TABLE_WAIT_MS 0
+#define IMX708_TABLE_END 1
+#define IMX708_WAIT_MS 1
+#define IMX708_STANDBY_REG 0x0100
+
+#define imx708_reg struct reg_8
+
+static const imx708_reg imx708_start[] = {
+	{IMX708_STANDBY_REG, 0x1},
+	{IMX708_TABLE_WAIT_MS, IMX708_WAIT_MS*3},
+	{IMX708_TABLE_END, 0x00}
+};
+
+static const imx708_reg imx708_stop[] = {
+	{IMX708_STANDBY_REG, 0x0},
+	{IMX708_TABLE_END, 0x00}
+};
+
+static const imx708_reg imx708_mode_common[] = {
+	/* software reset */
+	{0x0103, 0x01},
+	{IMX708_TABLE_WAIT_MS, IMX708_WAIT_MS*10},
+	{0x0100, 0x00},
+	{0x0136, 0x18},
+	{0x0137, 0x00},
+	{0x33F0, 0x02},
+	{0x33F1, 0x05},
+	{0x3062, 0x00},
+	{0x3063, 0x12},
+	{0x3068, 0x00},
+	{0x3069, 0x12},
+	{0x306A, 0x00},
+	{0x306B, 0x30},
+	{0x3076, 0x00},
+	{0x3077, 0x30},
+	{0x3078, 0x00},
+	{0x3079, 0x30},
+	{0x5E54, 0x0C},
+	{0x6E44, 0x00},
+	{0xB0B6, 0x01},
+	{0xE829, 0x00},
+	{0xF001, 0x08},
+	{0xF003, 0x08},
+	{0xF00D, 0x10},
+	{0xF00F, 0x10},
+	{0xF031, 0x08},
+	{0x0830, 0x01},
+	{0x0831, 0x01}, 
+	{0x0832, 0x01},
+	{0xF033, 0x08},
+	{0xF03D, 0x10},
+	{0xF03F, 0x10},
+	{0x0112, 0x0a},
+	{0x0113, 0x0a},
+	{0x0114, 0x01},
+	{0x0B8E, 0x01},
+	{0x0B8F, 0x00},
+	{0x0B94, 0x01},
+	{0x0B95, 0x00},
+	{0x3400, 0x01},
+	{0x3478, 0x01},
+	{0x3479, 0x1c},
+	{0x3091, 0x01},
+	{0x3092, 0x00},
+	{0x3419, 0x00},
+	{0xBCF1, 0x02},
+	{0x3094, 0x01},
+	{0x3095, 0x01},
+	{0x3362, 0x00},
+	{0x3363, 0x00},
+	{0x3364, 0x00},
+	{0x3365, 0x00},
+	{0x0138, 0x01},
+	{IMX708_TABLE_END, 0x0000}
+};
+
+static const imx708_reg imx708_mode_4608x2592_14fps[] = {
+	{0x0342, 0x3D},
+	{0x0343, 0x20},
+	{0x0340, 0x0A},
+	{0x0341, 0x5a},
+	{0x0344, 0x00},
+	{0x0345, 0x00},
+	{0x0346, 0x00},
+	{0x0347, 0x00},
+	{0x0348, 0x11},
+	{0x0349, 0xFF},
+	{0x034A, 0X0A},
+	{0x034B, 0x1F},
+	{0x0220, 0x62},
+	{0x0222, 0x01},
+	{0x0900, 0x00},
+	{0x0901, 0x11},
+	{0x0902, 0x0A},
+	{0x3200, 0x01},
+	{0x3201, 0x01},
+	{0x32D5, 0x01},
+	{0x32D6, 0x00},
+	{0x32DB, 0x01},
+	{0x32DF, 0x00},
+	{0x350C, 0x00},
+	{0x350D, 0x00},
+	{0x0408, 0x00},
+	{0x0409, 0x00},
+	{0x040A, 0x00},
+	{0x040B, 0x00},
+	{0x040C, 0x12},
+	{0x040D, 0x00},
+	{0x040E, 0x0A},
+	{0x040F, 0x20},
+	{0x034C, 0x12},
+	{0x034D, 0x00},
+	{0x034E, 0x0A},
+	{0x034F, 0x20},
+	{0x0301, 0x05},
+	{0x0303, 0x02},
+	{0x0305, 0x02},
+	{0x0306, 0x00},
+	{0x0307, 0x7C},
+	{0x030B, 0x02},
+	{0x030D, 0x04},
+	{0x030E, 0x01},
+	{0x030F, 0x2C},
+	{0x0310, 0x01},
+	{0x3CA0, 0x00},
+	{0x3CA1, 0x64},
+	{0x3CA4, 0x00},
+	{0x3CA5, 0x00},
+	{0x3CA6, 0x00},
+	{0x3CA7, 0x00},
+	{0x3CAA, 0x00},
+	{0x3CAB, 0x00},
+	{0x3CB8, 0x00},
+	{0x3CB9, 0x08},
+	{0x3CBA, 0x00},
+	{0x3CBB, 0x00},
+	{0x3CBC, 0x00},
+	{0x3CBD, 0x3C},
+	{0x3CBE, 0x00},
+	{0x3CBF, 0x00},
+	{0x0202, 0x0A},
+	{0x0203, 0x2a},
+	{0x0224, 0x01},
+	{0x0225, 0xF4},
+	{0x3116, 0x01},
+	{0x3117, 0xF4},
+	{0x0204, 0x03},
+	{0x0205, 0x55},
+	{0x0216, 0x00},
+	{0x0217, 0x00},
+	{0x0218, 0x01},
+	{0x0219, 0x00},
+	{0x020E, 0x01},
+	{0x020F, 0x00},
+	{0x3118, 0x00},
+	{0x3119, 0x00},
+	{0x311A, 0x01},
+	{0x311B, 0x00},
+	{0x341a, 0x00},
+	{0x341b, 0x00},
+	{0x341c, 0x00},
+	{0x341d, 0x00},
+	{0x341e, 0x01},
+	{0x341f, 0x20},
+	{0x3420, 0x00},
+	{0x3421, 0xd8},
+	{0xC428, 0x00},
+	{0xC429, 0x04},
+	{0x3366, 0x00},
+	{0x3367, 0x00},
+	{0x3368, 0x00},
+	{0x3369, 0x00},
+	{IMX708_TABLE_WAIT_MS, IMX708_WAIT_MS},
+	{IMX708_TABLE_END, 0x0000}
+};
+
+enum {
+	IMX708_MODE_4608x2592_14FPS,
+	IMX708_MODE_COMMON,
+	IMX708_START_STREAM,
+	IMX708_STOP_STREAM,
+};
+
+static const imx708_reg *mode_table[] = {
+	[IMX708_MODE_4608x2592_14FPS] = imx708_mode_4608x2592_14fps,
+	[IMX708_MODE_COMMON] = imx708_mode_common,
+	[IMX708_START_STREAM] = imx708_start,
+	[IMX708_STOP_STREAM] = imx708_stop,
+};
+
+static const int imx708_14_fr[] = {
+	14,
+};
+
+static const struct camera_common_frmfmt imx708_frmfmt[] = {
+	{{4608, 2592}, imx708_14_fr, 1, 0, IMX708_MODE_4608x2592_14FPS},
+};
+#endif
diff --git a/kernel/nvidia/include/media/imx708.h b/kernel/nvidia/include/media/imx708.h
new file mode 100644
index 000000000..972aa1a62
--- /dev/null
+++ b/kernel/nvidia/include/media/imx708.h
@@ -0,0 +1,51 @@
+/*
+ * imx708.h - imx708 sensor header
+ *
+ * Copyright (c) 2023, RidgeRun <support@ridgerun.com>. All rights reserved.
+ *
+ * Contact us: support@ridgerun.com
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __IMX708_H__
+#define __IMX708_H__
+
+/* imx708 - sensor parameters */
+#define IMX708_MIN_GAIN		                (0)
+#define IMX708_MAX_GAIN		                (978)
+#define IMX708_ANALOG_GAIN_C0		        (516)
+#define IMX708_SHIFT_8_BITS			(8)
+#define IMX708_MIN_FRAME_LENGTH		        (256)
+#define IMX708_MAX_FRAME_LENGTH		        (65535)
+#define IMX708_MASK_LSB_2_BITS			0x0003
+#define IMX708_MASK_LSB_8_BITS			0x00ff
+
+/* imx708 sensor register address */
+#define IMX708_MODEL_ID_ADDR_MSB		0x0000
+#define IMX708_MODEL_ID_ADDR_LSB		0x0001
+#define IMX708_MODEL_ID_VALUE_MSB       0x0003
+#define IMX708_MODEL_ID_VALUE_LSB       0x0001
+#define IMX708_ANALOG_GAIN_ADDR_MSB		0x0204
+#define IMX708_ANALOG_GAIN_ADDR_LSB		0x0205
+#define IMX708_DIGITAL_GAIN_ADDR_MSB		0x020e
+#define IMX708_DIGITAL_GAIN_ADDR_LSB		0x020f
+#define IMX708_FRAME_LENGTH_ADDR_MSB		0x0340
+#define IMX708_FRAME_LENGTH_ADDR_LSB		0x0341
+#define IMX708_COARSE_INTEG_TIME_ADDR_MSB	0x0202
+#define IMX708_COARSE_INTEG_TIME_ADDR_LSB	0x0203
+#define IMX708_FINE_INTEG_TIME_ADDR_MSB		0x0200
+#define IMX708_FINE_INTEG_TIME_ADDR_LSB		0x0201
+#define IMX708_GROUP_HOLD_ADDR		        0x0104
+
+#endif /* __IMX708_H__ */
-- 
2.17.1

